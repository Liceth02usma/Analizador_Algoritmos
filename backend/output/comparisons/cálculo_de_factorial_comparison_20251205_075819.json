{
  "metadata": {
    "algorithm_name": "CÃ¡lculo de Factorial",
    "compared_at": "2025-12-05T07:58:19.980586",
    "specialized_timestamp": "2025-12-05T07:57:54.689192"
  },
  "tokens_comparison": {
    "specialized": {
      "input": 0,
      "output": 0,
      "total": 0
    },
    "complete": {
      "input": 0,
      "output": 0,
      "total": 0
    },
    "difference": {
      "input": 0,
      "output": 0,
      "total": 0
    },
    "percentage_difference": {
      "total": 0
    }
  },
  "complexity_comparison": {
    "specialized": "N/A",
    "complete": "N/A",
    "match": false
  },
  "methods_comparison": {
    "specialized": [
      "AnÃ¡lisis especializado multi-agente"
    ],
    "complete": "AnÃ¡lisis completo sin especializaciÃ³n"
  },
  "detail_comparison": {
    "specialized_steps": 0,
    "complete_steps": 0,
    "specialized_cases": 0,
    "complete_cases": 1
  },
  "execution_time": {
    "specialized": 0,
    "complete": 22.19926619529724
  },
  "full_results": {
    "specialized": {
      "type": "iterativo",
      "code_explain": "El algoritmo factorial tiene un caso general porque su comportamiento no depende de la entrada especÃ­fica.",
      "complexity_line_to_line": "=== MEJOR ===\nfactorial(n) // Costo: 1 * 1\nbegin // Costo: 0 * 1\n    f ðŸ¡¨ 1 // Costo: 1 * 1\n    for i ðŸ¡¨ 1 to n do // Costo: 3 * (n + 1)\n    begin // Costo: 0 * n\n        f ðŸ¡¨ f * i // Costo: 2 * n\n    end // Costo: 0 * n\n    return f // Costo: 1 * 1\nend // Costo: 0 * 1\n\n=== PROMEDIO ===\nfactorial(n) // Costo: 1 * 1\nbegin // Costo: 0 * 1\n    f ðŸ¡¨ 1 // Costo: 1 * 1\n    for i ðŸ¡¨ 1 to n do // Costo: 3 * (n + 1)\n    begin // Costo: 0 * n\n        f ðŸ¡¨ f * i // Costo: 2 * n\n    end // Costo: 0 * n\n    return f // Costo: 1 * 1\nend // Costo: 0 * 1\n\n=== PEOR ===\nfactorial(n) // Costo: 1 * 1\nbegin // Costo: 0 * 1\n    f ðŸ¡¨ 1 // Costo: 1 * 1\n    for i ðŸ¡¨ 1 to n do // Costo: 3 * (n + 1)\n    begin // Costo: 0 * n\n        f ðŸ¡¨ f * i // Costo: 2 * n\n    end // Costo: 0 * n\n    return f // Costo: 1 * 1\nend // Costo: 0 * 1\n\n",
      "explain_complexity": "El algoritmo CÃ¡lculo de Factorial tiene una complejidad O(n) en todos los casos.",
      "asymptotic_notation": {
        "best": "Î©(n)",
        "average": "Î˜(n)",
        "worst": "O(n)",
        "explanation": "La complejidad asintÃ³tica para el CÃ¡lculo de Factorial en el caso general es Î˜(n)."
      },
      "algorithm_name": "CÃ¡lculo de Factorial",
      "algorithm_category": "Iterativo / Bucle",
      "equation": [
        "Mejor: 1 * 1 + 0 * 1 + 1 * 1 + 3 * (n + 1) + 0 * n + 2 * n + 0 * n + 1 * 1 + 0 * 1",
        "Promedio: 1 * 1 + 0 * 1 + 1 * 1 + 3 * (n + 1) + 0 * n + 2 * n + 0 * n + 1 * 1 + 0 * 1",
        "Peor: 1 * 1 + 0 * 1 + 1 * 1 + 3 * (n + 1) + 0 * n + 2 * n + 0 * n + 1 * 1 + 0 * 1"
      ],
      "method_solution": "MÃ©todo de Conteo de Pasos + Sumatorias",
      "solution_equation": [
        "Mejor: T(n) = 5*n + 6",
        "Promedio: T(n) = 5*n + 6",
        "Peor: T(n) = 5*n + 6"
      ],
      "explain_solution_steps": [
        "**Mejor**: La funciÃ³n de tiempo resultante, T(n) = 5n + 6, es una funciÃ³n lineal. Esto significa que el nÃºmero total de operaciones que realiza el algoritmo crece directamente proporcional al tamaÃ±o de la entrada `n`. El tÃ©rmino dominante es `5n`, ya que para valores grandes de `n`, el tÃ©rmino constante `6` se vuelve insignificante en comparaciÃ³n. Por lo tanto, la complejidad del algoritmo es O(n), indicando un rendimiento eficiente que escala linealmente con el tamaÃ±o del problema.",
        "**Promedio**: 5*n + 6",
        "**Peor**: 5*n + 6"
      ],
      "diagrams": {
        "main_flowchart": "graph TD\n    Start((Inicio)) --> InitF[\"f := 1\"]\n    InitF --> InitI[\"i := 1\"]\n    InitI --> CheckLoop{i <= n?}\n    CheckLoop -->|SÃ­| Multiply[\"f := f * i\"]\n    Multiply --> IncrementI[\"i := i + 1\"]\n    IncrementI --> CheckLoop\n    CheckLoop -->|No| ReturnF[\"Return f\"]\n    ReturnF --> End((Fin))"
      },
      "extra": {
        "is_case_dependent": false,
        "cases": [
          {
            "case_name": "Mejor",
            "condition": "n >= 0",
            "line_analysis": [
              {
                "line": 1,
                "cost_constant": 1,
                "execution_count": "1",
                "total_cost_expression": "1 * 1"
              },
              {
                "line": 2,
                "cost_constant": 0,
                "execution_count": "1",
                "total_cost_expression": "0 * 1"
              },
              {
                "line": 3,
                "cost_constant": 1,
                "execution_count": "1",
                "total_cost_expression": "1 * 1"
              },
              {
                "line": 4,
                "cost_constant": 3,
                "execution_count": "n + 1",
                "total_cost_expression": "3 * (n + 1)"
              },
              {
                "line": 5,
                "cost_constant": 0,
                "execution_count": "n",
                "total_cost_expression": "0 * n"
              },
              {
                "line": 6,
                "cost_constant": 2,
                "execution_count": "n",
                "total_cost_expression": "2 * n"
              },
              {
                "line": 7,
                "cost_constant": 0,
                "execution_count": "n",
                "total_cost_expression": "0 * n"
              },
              {
                "line": 8,
                "cost_constant": 1,
                "execution_count": "1",
                "total_cost_expression": "1 * 1"
              },
              {
                "line": 9,
                "cost_constant": 0,
                "execution_count": "1",
                "total_cost_expression": "0 * 1"
              }
            ],
            "raw_summation_str": "1 * 1 + 0 * 1 + 1 * 1 + 3 * (n + 1) + 0 * n + 2 * n + 0 * n + 1 * 1 + 0 * 1",
            "math_steps": "5*n + 6",
            "simplified_complexity": "5*n + 6",
            "complexity_class": "n",
            "notation_type": "Î©",
            "big_o": "Î©(n)",
            "trace_diagram": "graph TD\n    Start((Inicio)) --> InitF[\"f := 1\"]\n    InitF --> InitI[\"i := 1\"]\n    InitI --> CheckLoop{i <= n?}\n    CheckLoop -->|SÃ­| Multiply[\"f := f * i\"]\n    Multiply --> IncrementI[\"i := i + 1\"]\n    IncrementI --> CheckLoop\n    CheckLoop -->|No| ReturnF[\"Return f\"]\n    ReturnF --> End((Fin))",
            "properties_explanation": "En esta expresiÃ³n, identificamos una serie de tÃ©rminos constantes y productos que involucran la variable `n`. No hay sumatorias complejas (como series aritmÃ©ticas o geomÃ©tricas) ni estructuras anidadas que requieran fÃ³rmulas especÃ­ficas de sumatorias.\n\nLas operaciones matemÃ¡ticas principales que aplicaremos son la multiplicaciÃ³n y la suma. Utilizaremos la propiedad distributiva para expandir los productos y luego combinaremos los tÃ©rminos semejantes.\n\nNuestra estrategia general serÃ¡ simplificar la expresiÃ³n de izquierda a derecha, resolviendo primero todos los productos y luego agrupando los tÃ©rminos constantes y los tÃ©rminos que contienen `n` para obtener una funciÃ³n polinÃ³mica simplificada. Esto nos permitirÃ¡ determinar fÃ¡cilmente el tÃ©rmino dominante y, por ende, la complejidad Big-O del algoritmo.",
            "resolution_steps": [
              {
                "step_number": 1,
                "title": "ExpresiÃ³n original limpia",
                "explanation": "Este es el punto de partida de nuestro anÃ¡lisis. AquÃ­ simplemente presentamos la expresiÃ³n tal como fue definida inicialmente, sin ninguna modificaciÃ³n. Es la base sobre la cual realizaremos todas las simplificaciones posteriores.",
                "mathematical_expression": "1*1+0*1+1*1+3*(n+1)+0*n+2*n+0*n+1*1+0*1",
                "property_or_formula": null
              },
              {
                "step_number": 2,
                "title": "Expandir productos y simplificar",
                "explanation": "En este paso, aplicamos las operaciones de multiplicaciÃ³n y suma para simplificar la expresiÃ³n. Primero, resolvemos todos los productos. Por ejemplo, `1*1` se convierte en `1`, `0*1` en `0`, `3*(n+1)` en `3n + 3`, `0*n` en `0`, y `2*n` se mantiene como `2n`. Luego, sumamos todos los tÃ©rminos constantes y todos los tÃ©rminos que contienen `n` por separado. Los tÃ©rminos multiplicados por cero simplemente desaparecen.",
                "mathematical_expression": "5*n + 6",
                "property_or_formula": "Propiedad distributiva de la multiplicaciÃ³n sobre la suma: a*(b+c) = a*b + a*c. SimplificaciÃ³n de productos y sumas."
              },
              {
                "step_number": 3,
                "title": "Agrupar tÃ©rminos por potencias de n",
                "explanation": "DespuÃ©s de expandir y simplificar, el siguiente paso es organizar la expresiÃ³n en su forma polinÃ³mica estÃ¡ndar. Esto significa agrupar los tÃ©rminos que tienen la misma potencia de `n`. En este caso, ya hemos combinado los tÃ©rminos con `n` (5n) y los tÃ©rminos constantes (6), resultando en una expresiÃ³n lineal clara y simplificada.",
                "mathematical_expression": "5*n + 6",
                "property_or_formula": "AgrupaciÃ³n de tÃ©rminos semejantes."
              }
            ],
            "final_summary": "La funciÃ³n de tiempo resultante, T(n) = 5n + 6, es una funciÃ³n lineal. Esto significa que el nÃºmero total de operaciones que realiza el algoritmo crece directamente proporcional al tamaÃ±o de la entrada `n`. El tÃ©rmino dominante es `5n`, ya que para valores grandes de `n`, el tÃ©rmino constante `6` se vuelve insignificante en comparaciÃ³n. Por lo tanto, la complejidad del algoritmo es O(n), indicando un rendimiento eficiente que escala linealmente con el tamaÃ±o del problema."
          },
          {
            "case_name": "Promedio",
            "condition": "n >= 0",
            "line_analysis": [
              {
                "line": 1,
                "cost_constant": 1,
                "execution_count": "1",
                "total_cost_expression": "1 * 1"
              },
              {
                "line": 2,
                "cost_constant": 0,
                "execution_count": "1",
                "total_cost_expression": "0 * 1"
              },
              {
                "line": 3,
                "cost_constant": 1,
                "execution_count": "1",
                "total_cost_expression": "1 * 1"
              },
              {
                "line": 4,
                "cost_constant": 3,
                "execution_count": "n + 1",
                "total_cost_expression": "3 * (n + 1)"
              },
              {
                "line": 5,
                "cost_constant": 0,
                "execution_count": "n",
                "total_cost_expression": "0 * n"
              },
              {
                "line": 6,
                "cost_constant": 2,
                "execution_count": "n",
                "total_cost_expression": "2 * n"
              },
              {
                "line": 7,
                "cost_constant": 0,
                "execution_count": "n",
                "total_cost_expression": "0 * n"
              },
              {
                "line": 8,
                "cost_constant": 1,
                "execution_count": "1",
                "total_cost_expression": "1 * 1"
              },
              {
                "line": 9,
                "cost_constant": 0,
                "execution_count": "1",
                "total_cost_expression": "0 * 1"
              }
            ],
            "raw_summation_str": "1 * 1 + 0 * 1 + 1 * 1 + 3 * (n + 1) + 0 * n + 2 * n + 0 * n + 1 * 1 + 0 * 1",
            "math_steps": "5*n + 6",
            "simplified_complexity": "5*n + 6",
            "complexity_class": "n",
            "notation_type": "Î˜",
            "big_o": "Î˜(n)",
            "trace_diagram": "graph TD\n    Start((Inicio)) --> InitF[\"f := 1\"]\n    InitF --> InitI[\"i := 1\"]\n    InitI --> CheckLoop{i <= n?}\n    CheckLoop -->|SÃ­| Multiply[\"f := f * i\"]\n    Multiply --> IncrementI[\"i := i + 1\"]\n    IncrementI --> CheckLoop\n    CheckLoop -->|No| ReturnF[\"Return f\"]\n    ReturnF --> End((Fin))"
          },
          {
            "case_name": "Peor",
            "condition": "n >= 0",
            "line_analysis": [
              {
                "line": 1,
                "cost_constant": 1,
                "execution_count": "1",
                "total_cost_expression": "1 * 1"
              },
              {
                "line": 2,
                "cost_constant": 0,
                "execution_count": "1",
                "total_cost_expression": "0 * 1"
              },
              {
                "line": 3,
                "cost_constant": 1,
                "execution_count": "1",
                "total_cost_expression": "1 * 1"
              },
              {
                "line": 4,
                "cost_constant": 3,
                "execution_count": "n + 1",
                "total_cost_expression": "3 * (n + 1)"
              },
              {
                "line": 5,
                "cost_constant": 0,
                "execution_count": "n",
                "total_cost_expression": "0 * n"
              },
              {
                "line": 6,
                "cost_constant": 2,
                "execution_count": "n",
                "total_cost_expression": "2 * n"
              },
              {
                "line": 7,
                "cost_constant": 0,
                "execution_count": "n",
                "total_cost_expression": "0 * n"
              },
              {
                "line": 8,
                "cost_constant": 1,
                "execution_count": "1",
                "total_cost_expression": "1 * 1"
              },
              {
                "line": 9,
                "cost_constant": 0,
                "execution_count": "1",
                "total_cost_expression": "0 * 1"
              }
            ],
            "raw_summation_str": "1 * 1 + 0 * 1 + 1 * 1 + 3 * (n + 1) + 0 * n + 2 * n + 0 * n + 1 * 1 + 0 * 1",
            "math_steps": "5*n + 6",
            "simplified_complexity": "5*n + 6",
            "complexity_class": "n",
            "notation_type": "O",
            "big_o": "O(n)",
            "trace_diagram": "graph TD\n    Start((Inicio)) --> InitF[\"f := 1\"]\n    InitF --> InitI[\"i := 1\"]\n    InitI --> CheckLoop{i <= n?}\n    CheckLoop -->|SÃ­| Multiply[\"f := f * i\"]\n    Multiply --> IncrementI[\"i := i + 1\"]\n    IncrementI --> CheckLoop\n    CheckLoop -->|No| ReturnF[\"Return f\"]\n    ReturnF --> End((Fin))"
          }
        ],
        "hybrid_solver_summary": "El algoritmo CÃ¡lculo de Factorial tiene una complejidad O(n) en todos los casos.",
        "project_metadata": {
          "diagrams_generated": 1,
          "agent_model": "Gemini_Rapido",
          "optimization": "Cases replicated"
        }
      }
    },
    "complete": {
      "type": "iterative",
      "code_explain": "Este algoritmo calcula el factorial de un nÃºmero entero no negativo 'n'. El factorial de n (denotado como n!) es el producto de todos los enteros positivos menores o iguales a n.",
      "complexity_line_to_line": [
        {
          "line": 1,
          "code": "f ðŸ¡¨ 1",
          "complexity": "c1 * 1",
          "explanation": "AsignaciÃ³n inicial. Se ejecuta una sola vez, por lo que su costo es constante."
        },
        {
          "line": 2,
          "code": "for i ðŸ¡¨ 1 to n do",
          "complexity": "c2 * n",
          "explanation": "El bucle se ejecuta n veces. Incluye n comparaciones (i <= n) y n incrementos (i++)."
        },
        {
          "line": 3,
          "code": "f ðŸ¡¨ f * i",
          "complexity": "c3 * n",
          "explanation": "OperaciÃ³n de multiplicaciÃ³n y asignaciÃ³n. Se ejecuta una vez por cada iteraciÃ³n del bucle, n veces en total."
        },
        {
          "line": 4,
          "code": "return f",
          "complexity": "c4 * 1",
          "explanation": "InstrucciÃ³n de retorno. Se ejecuta una sola vez, por lo que su costo es constante."
        }
      ],
      "explain_complexity": "**Algoritmo**: Factorial Iterativo\n**CategorÃ­a**: IteraciÃ³n Simple\n**Tipo**: Iterativo\n\n**EcuaciÃ³n**: T(n) = c1 + c4 + Î£(i=1 to n) (c2 + c3)\n**MÃ©todo de resoluciÃ³n**: AnÃ¡lisis de Sumatorias\n**Complejidad final**: O(n)\n\n**Notaciones asintÃ³ticas**:\n- Mejor caso (Î©): Î©(n)\n- Peor caso (O): O(n)\n- Caso promedio (Î˜): Î˜(n)",
      "asymptotic_notation": {
        "best": "Î©(n)",
        "worst": "O(n)",
        "average": "Î˜(n)",
        "explanation": "Î© (Omega) representa la cota inferior del tiempo de ejecuciÃ³n. El algoritmo tardarÃ¡ *al menos* un tiempo proporcional a n, ya que el bucle siempre se ejecuta n veces.\nO (Big-O) representa la cota superior. El algoritmo tardarÃ¡ *como mÃ¡ximo* un tiempo proporcional a n, ya que el bucle nunca se ejecutarÃ¡ mÃ¡s de n veces.\nÎ˜ (Theta) representa la cota ajustada, que se da cuando las cotas inferior y superior coinciden. Indica que el tiempo de ejecuciÃ³n crece de forma directamente proporcional a n en todos los casos."
      },
      "algorithm_name": "Factorial Iterativo",
      "algorithm_category": "IteraciÃ³n Simple",
      "equation": "T(n) = c1 + c4 + Î£(i=1 to n) (c2 + c3)",
      "method_solution": "AnÃ¡lisis de Sumatorias",
      "solution_equation": "O(n)",
      "explain_solution_steps": [
        "La funciÃ³n de complejidad T(n) se obtiene sumando los costos de cada lÃ­nea. Las operaciones fuera del bucle tienen un costo constante y las de adentro se suman n veces.",
        "EcuaciÃ³n: T(n) = (costo lÃ­nea 1) + (costo bucle) + (costo cuerpo del bucle) + (costo lÃ­nea 4)",
        "T(n) = c1 + Î£(i=1 to n) (c2 + c3) + c4",
        "Agrupamos las constantes que estÃ¡n fuera de la sumatoria: T(n) = (c1 + c4) + Î£(i=1 to n) (c2 + c3)",
        "Sea C_in = c2 + c3, una nueva constante que representa el costo de una iteraciÃ³n. La sumatoria de una constante C_in desde 1 hasta n es C_in * n.",
        "T(n) = (c1 + c4) + (c2 + c3) * n",
        "En el anÃ¡lisis asintÃ³tico, nos centramos en el tÃ©rmino de mayor orden y despreciamos las constantes. El tÃ©rmino dominante es n.",
        "Por lo tanto, la complejidad del algoritmo es lineal con respecto a n."
      ],
      "diagrams": null,
      "extra": {
        "pseudocode": "factorial(n)\nbegin\n    f ðŸ¡¨ 1\n    for i ðŸ¡¨ 1 to n do\n    begin\n        f ðŸ¡¨ f * i\n    end\n    return f\nend",
        "analysis_complete": true
      }
    }
  }
}