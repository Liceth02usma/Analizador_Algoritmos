{
  "metadata": {
    "algorithm_name": "C谩lculo de Factorial",
    "compared_at": "2025-12-05T08:17:12.534265",
    "specialized_timestamp": "2025-12-05T08:07:18.712409"
  },
  "tokens_comparison": {
    "specialized": {
      "input": 2830,
      "output": 1983,
      "total": 4813
    },
    "complete": {
      "input": 1523,
      "output": 2000,
      "total": 3523
    },
    "difference": {
      "input": 1307,
      "output": -17,
      "total": 1290
    },
    "percentage_difference": {
      "total": 36.616520011353956
    }
  },
  "complexity_comparison": {
    "specialized": "N/A",
    "complete": "N/A",
    "match": false
  },
  "methods_comparison": {
    "specialized": [
      "An谩lisis especializado multi-agente"
    ],
    "complete": "An谩lisis completo sin especializaci贸n"
  },
  "detail_comparison": {
    "specialized_steps": 0,
    "complete_steps": 0,
    "specialized_cases": 0,
    "complete_cases": 1
  },
  "execution_time": {
    "specialized": 51.126529693603516,
    "complete": 17.2869873046875
  },
  "full_results": {
    "specialized": {
      "type": "iterativo",
      "code_explain": "El algoritmo factorial tiene un caso general porque su comportamiento no depende de la entrada espec铆fica.",
      "complexity_line_to_line": "=== MEJOR ===\nfactorial(n) // Costo: 1 * 1\nbegin // Costo: 0 * 1\n    f 〃 1 // Costo: 1 * 1\n    for i 〃 1 to n do // Costo: 3 * (n + 1)\n    begin // Costo: 0 * n\n        f 〃 f * i // Costo: 2 * n\n    end // Costo: 0 * n\n    return f // Costo: 1 * 1\nend // Costo: 0 * 1\n\n=== PROMEDIO ===\nfactorial(n) // Costo: 1 * 1\nbegin // Costo: 0 * 1\n    f 〃 1 // Costo: 1 * 1\n    for i 〃 1 to n do // Costo: 3 * (n + 1)\n    begin // Costo: 0 * n\n        f 〃 f * i // Costo: 2 * n\n    end // Costo: 0 * n\n    return f // Costo: 1 * 1\nend // Costo: 0 * 1\n\n=== PEOR ===\nfactorial(n) // Costo: 1 * 1\nbegin // Costo: 0 * 1\n    f 〃 1 // Costo: 1 * 1\n    for i 〃 1 to n do // Costo: 3 * (n + 1)\n    begin // Costo: 0 * n\n        f 〃 f * i // Costo: 2 * n\n    end // Costo: 0 * n\n    return f // Costo: 1 * 1\nend // Costo: 0 * 1\n\n",
      "explain_complexity": "El algoritmo C谩lculo de Factorial tiene una complejidad O(n) en todos los casos.",
      "asymptotic_notation": {
        "best": "惟(n)",
        "average": "(n)",
        "worst": "O(n)",
        "explanation": "La complejidad asint贸tica para el C谩lculo de Factorial en el caso general es (n)."
      },
      "algorithm_name": "C谩lculo de Factorial",
      "algorithm_category": "Iterativo / Bucle",
      "equation": [
        "Mejor: 1 * 1 + 0 * 1 + 1 * 1 + 3 * (n + 1) + 0 * n + 2 * n + 0 * n + 1 * 1 + 0 * 1",
        "Promedio: 1 * 1 + 0 * 1 + 1 * 1 + 3 * (n + 1) + 0 * n + 2 * n + 0 * n + 1 * 1 + 0 * 1",
        "Peor: 1 * 1 + 0 * 1 + 1 * 1 + 3 * (n + 1) + 0 * n + 2 * n + 0 * n + 1 * 1 + 0 * 1"
      ],
      "method_solution": "M茅todo de Conteo de Pasos + Sumatorias",
      "solution_equation": [
        "Mejor: T(n) = 5*n + 6",
        "Promedio: T(n) = 5*n + 6",
        "Peor: T(n) = 5*n + 6"
      ],
      "explain_solution_steps": [
        "**Mejor**: Hemos obtenido una funci贸n de tiempo T(n) = 5n + 6. Esta es una funci贸n lineal, donde el t茅rmino dominante es 5n. Para valores grandes de 'n', el t茅rmino constante '6' se vuelve insignificante en comparaci贸n con '5n'. Por lo tanto, la complejidad del algoritmo es O(n), lo que indica que el tiempo de ejecuci贸n crece linealmente con el tama帽o de la entrada 'n'.",
        "**Promedio**: 5*n + 6",
        "**Peor**: 5*n + 6"
      ],
      "diagrams": {
        "main_flowchart": "graph TD\n    Start((Inicio)) --> InitF[\"f := 1\"]\n    InitF --> InitI[\"i := 1\"]\n    InitI --> CheckLoop{i <= n?}\n    CheckLoop -->|S铆| Multiply[\"f := f * i\"]\n    Multiply --> IncrementI[\"i := i + 1\"]\n    IncrementI --> CheckLoop\n    CheckLoop -->|No| ReturnF[\"Return f\"]\n    ReturnF --> End((Fin))"
      },
      "extra": {
        "is_case_dependent": false,
        "cases": [
          {
            "case_name": "Mejor",
            "condition": "n >= 0",
            "line_analysis": [
              {
                "line": 1,
                "cost_constant": 1,
                "execution_count": "1",
                "total_cost_expression": "1 * 1"
              },
              {
                "line": 2,
                "cost_constant": 0,
                "execution_count": "1",
                "total_cost_expression": "0 * 1"
              },
              {
                "line": 3,
                "cost_constant": 1,
                "execution_count": "1",
                "total_cost_expression": "1 * 1"
              },
              {
                "line": 4,
                "cost_constant": 3,
                "execution_count": "n + 1",
                "total_cost_expression": "3 * (n + 1)"
              },
              {
                "line": 5,
                "cost_constant": 0,
                "execution_count": "n",
                "total_cost_expression": "0 * n"
              },
              {
                "line": 6,
                "cost_constant": 2,
                "execution_count": "n",
                "total_cost_expression": "2 * n"
              },
              {
                "line": 7,
                "cost_constant": 0,
                "execution_count": "n",
                "total_cost_expression": "0 * n"
              },
              {
                "line": 8,
                "cost_constant": 1,
                "execution_count": "1",
                "total_cost_expression": "1 * 1"
              },
              {
                "line": 9,
                "cost_constant": 0,
                "execution_count": "1",
                "total_cost_expression": "0 * 1"
              }
            ],
            "raw_summation_str": "1 * 1 + 0 * 1 + 1 * 1 + 3 * (n + 1) + 0 * n + 2 * n + 0 * n + 1 * 1 + 0 * 1",
            "math_steps": "5*n + 6",
            "simplified_complexity": "5*n + 6",
            "complexity_class": "n",
            "notation_type": "惟",
            "big_o": "惟(n)",
            "trace_diagram": "graph TD\n    Start((Inicio)) --> InitF[\"f := 1\"]\n    InitF --> InitI[\"i := 1\"]\n    InitI --> CheckLoop{i <= n?}\n    CheckLoop -->|S铆| Multiply[\"f := f * i\"]\n    Multiply --> IncrementI[\"i := i + 1\"]\n    IncrementI --> CheckLoop\n    CheckLoop -->|No| ReturnF[\"Return f\"]\n    ReturnF --> End((Fin))",
            "properties_explanation": "En esta expresi贸n, identificamos una serie de t茅rminos constantes y t茅rminos que involucran la variable 'n'. No hay sumatorias complejas ni anidadas, solo operaciones aritm茅ticas b谩sicas como multiplicaci贸n y suma. \n\nPara resolver esta expresi贸n, aplicaremos las propiedades fundamentales del 谩lgebra: la propiedad distributiva para expandir productos, la propiedad de la multiplicaci贸n por cero y por uno para simplificar t茅rminos, y finalmente, la agrupaci贸n de t茅rminos semejantes. \n\nLa estrategia general consiste en simplificar primero todos los productos y luego combinar los t茅rminos constantes entre s铆 y los t茅rminos que contienen 'n' entre s铆, para llegar a una expresi贸n polin贸mica simplificada en funci贸n de 'n'.",
            "resolution_steps": [
              {
                "step_number": 1,
                "title": "Identificaci贸n de la Expresi贸n Original",
                "explanation": "Comenzamos con la expresi贸n tal como se nos ha proporcionado. Este es nuestro punto de partida para el an谩lisis, sin ninguna modificaci贸n a煤n.",
                "mathematical_expression": "1*1+0*1+1*1+3*(n+1)+0*n+2*n+0*n+1*1+0*1",
                "property_or_formula": "Expresi贸n inicial"
              },
              {
                "step_number": 2,
                "title": "Expansi贸n de Productos y Simplificaci贸n Inicial",
                "explanation": "En este paso, realizamos todas las multiplicaciones y aplicamos la propiedad distributiva. Cualquier t茅rmino multiplicado por cero se convierte en cero, y cualquier t茅rmino multiplicado por uno permanece igual. Tambi茅n distribuimos el '3' en el t茅rmino '(n+1)'.\n\nDesglose de la simplificaci贸n:\n- `1*1` se convierte en `1`\n- `0*1` se convierte en `0`\n- `1*1` se convierte en `1`\n- `3*(n+1)` se expande a `3*n + 3*1`, que es `3n + 3`\n- `0*n` se convierte en `0`\n- `2*n` permanece como `2n`\n- `0*n` se convierte en `0`\n- `1*1` se convierte en `1`\n- `0*1` se convierte en `0`\n\nSumando los resultados: `1 + 0 + 1 + (3n + 3) + 0 + 2n + 0 + 1 + 0`",
                "mathematical_expression": "5*n + 6",
                "property_or_formula": "Propiedad distributiva: a*(b+c) = a*b + a*c\nMultiplicaci贸n por cero: x*0 = 0\nMultiplicaci贸n por uno: x*1 = x"
              },
              {
                "step_number": 3,
                "title": "Agrupaci贸n de T茅rminos Similares",
                "explanation": "Finalmente, agrupamos los t茅rminos que contienen 'n' y los t茅rminos constantes. Sumamos `3n + 2n` para obtener `5n`, y sumamos los t茅rminos constantes `1 + 1 + 3 + 1` para obtener `6`. Esto nos da la expresi贸n simplificada final.",
                "mathematical_expression": "5*n + 6",
                "property_or_formula": "Propiedad asociativa y conmutativa de la suma"
              }
            ],
            "final_summary": "Hemos obtenido una funci贸n de tiempo T(n) = 5n + 6. Esta es una funci贸n lineal, donde el t茅rmino dominante es 5n. Para valores grandes de 'n', el t茅rmino constante '6' se vuelve insignificante en comparaci贸n con '5n'. Por lo tanto, la complejidad del algoritmo es O(n), lo que indica que el tiempo de ejecuci贸n crece linealmente con el tama帽o de la entrada 'n'."
          },
          {
            "case_name": "Promedio",
            "condition": "n >= 0",
            "line_analysis": [
              {
                "line": 1,
                "cost_constant": 1,
                "execution_count": "1",
                "total_cost_expression": "1 * 1"
              },
              {
                "line": 2,
                "cost_constant": 0,
                "execution_count": "1",
                "total_cost_expression": "0 * 1"
              },
              {
                "line": 3,
                "cost_constant": 1,
                "execution_count": "1",
                "total_cost_expression": "1 * 1"
              },
              {
                "line": 4,
                "cost_constant": 3,
                "execution_count": "n + 1",
                "total_cost_expression": "3 * (n + 1)"
              },
              {
                "line": 5,
                "cost_constant": 0,
                "execution_count": "n",
                "total_cost_expression": "0 * n"
              },
              {
                "line": 6,
                "cost_constant": 2,
                "execution_count": "n",
                "total_cost_expression": "2 * n"
              },
              {
                "line": 7,
                "cost_constant": 0,
                "execution_count": "n",
                "total_cost_expression": "0 * n"
              },
              {
                "line": 8,
                "cost_constant": 1,
                "execution_count": "1",
                "total_cost_expression": "1 * 1"
              },
              {
                "line": 9,
                "cost_constant": 0,
                "execution_count": "1",
                "total_cost_expression": "0 * 1"
              }
            ],
            "raw_summation_str": "1 * 1 + 0 * 1 + 1 * 1 + 3 * (n + 1) + 0 * n + 2 * n + 0 * n + 1 * 1 + 0 * 1",
            "math_steps": "5*n + 6",
            "simplified_complexity": "5*n + 6",
            "complexity_class": "n",
            "notation_type": "",
            "big_o": "(n)",
            "trace_diagram": "graph TD\n    Start((Inicio)) --> InitF[\"f := 1\"]\n    InitF --> InitI[\"i := 1\"]\n    InitI --> CheckLoop{i <= n?}\n    CheckLoop -->|S铆| Multiply[\"f := f * i\"]\n    Multiply --> IncrementI[\"i := i + 1\"]\n    IncrementI --> CheckLoop\n    CheckLoop -->|No| ReturnF[\"Return f\"]\n    ReturnF --> End((Fin))"
          },
          {
            "case_name": "Peor",
            "condition": "n >= 0",
            "line_analysis": [
              {
                "line": 1,
                "cost_constant": 1,
                "execution_count": "1",
                "total_cost_expression": "1 * 1"
              },
              {
                "line": 2,
                "cost_constant": 0,
                "execution_count": "1",
                "total_cost_expression": "0 * 1"
              },
              {
                "line": 3,
                "cost_constant": 1,
                "execution_count": "1",
                "total_cost_expression": "1 * 1"
              },
              {
                "line": 4,
                "cost_constant": 3,
                "execution_count": "n + 1",
                "total_cost_expression": "3 * (n + 1)"
              },
              {
                "line": 5,
                "cost_constant": 0,
                "execution_count": "n",
                "total_cost_expression": "0 * n"
              },
              {
                "line": 6,
                "cost_constant": 2,
                "execution_count": "n",
                "total_cost_expression": "2 * n"
              },
              {
                "line": 7,
                "cost_constant": 0,
                "execution_count": "n",
                "total_cost_expression": "0 * n"
              },
              {
                "line": 8,
                "cost_constant": 1,
                "execution_count": "1",
                "total_cost_expression": "1 * 1"
              },
              {
                "line": 9,
                "cost_constant": 0,
                "execution_count": "1",
                "total_cost_expression": "0 * 1"
              }
            ],
            "raw_summation_str": "1 * 1 + 0 * 1 + 1 * 1 + 3 * (n + 1) + 0 * n + 2 * n + 0 * n + 1 * 1 + 0 * 1",
            "math_steps": "5*n + 6",
            "simplified_complexity": "5*n + 6",
            "complexity_class": "n",
            "notation_type": "O",
            "big_o": "O(n)",
            "trace_diagram": "graph TD\n    Start((Inicio)) --> InitF[\"f := 1\"]\n    InitF --> InitI[\"i := 1\"]\n    InitI --> CheckLoop{i <= n?}\n    CheckLoop -->|S铆| Multiply[\"f := f * i\"]\n    Multiply --> IncrementI[\"i := i + 1\"]\n    IncrementI --> CheckLoop\n    CheckLoop -->|No| ReturnF[\"Return f\"]\n    ReturnF --> End((Fin))"
          }
        ],
        "hybrid_solver_summary": "El algoritmo C谩lculo de Factorial tiene una complejidad O(n) en todos los casos.",
        "project_metadata": {
          "diagrams_generated": 1,
          "agent_model": "Gemini_Rapido",
          "optimization": "Cases replicated",
          "execution_time": 51.126529693603516,
          "token_usage": {
            "IterativeAnalyzerAgent": {
              "input": 926,
              "output": 289,
              "total": 1215
            },
            "HybridSummationSolverAgent": {
              "input": 0,
              "output": 0,
              "total": 0
            },
            "ComplexityAnalysisAgent": {
              "input": 603,
              "output": 334,
              "total": 937
            },
            "TraceDiagramAgent": {
              "input": 1301,
              "output": 1360,
              "total": 2661
            }
          },
          "total_tokens": {
            "input": 2830,
            "output": 1983,
            "total": 4813
          }
        }
      }
    },
    "complete": {
      "type": "iterative",
      "code_explain": "Este algoritmo calcula el factorial de un n煤mero entero no negativo 'n'. El factorial (denotado como n!) es el producto de todos los enteros positivos desde 1 hasta n.",
      "complexity_line_to_line": [
        {
          "line": 1,
          "code": "f 〃 1",
          "complexity": "c1 * 1",
          "explanation": "Asignaci贸n inicial. Se ejecuta una sola vez, costo constante."
        },
        {
          "line": 2,
          "code": "for i 〃 1 to n do",
          "complexity": "c2 * n",
          "explanation": "El bucle se ejecuta n veces. Incluye inicializaci贸n, n comparaciones y n incrementos."
        },
        {
          "line": 3,
          "code": "f 〃 f * i",
          "complexity": "c3 * n",
          "explanation": "Operaci贸n de multiplicaci贸n y asignaci贸n. Se ejecuta una vez por cada iteraci贸n del bucle, total n veces."
        },
        {
          "line": 4,
          "code": "return f",
          "complexity": "c4 * 1",
          "explanation": "Instrucci贸n de retorno. Se ejecuta una sola vez, costo constante."
        }
      ],
      "explain_complexity": "**Algoritmo**: Factorial Iterativo\n**Categor铆a**: Iteraci贸n Simple\n**Tipo**: Iterativo\n\n**Ecuaci贸n**: T(n) = c1 + c4 + 危(i=1 to n) (c2 + c3)\n**M茅todo de resoluci贸n**: An谩lisis de Sumatorias\n**Complejidad final**: O(n)\n\n**Notaciones asint贸ticas**:\n- Mejor caso (惟): 惟(n)\n- Peor caso (O): O(n)\n- Caso promedio (): (n)",
      "asymptotic_notation": {
        "best": "惟(n)",
        "worst": "O(n)",
        "average": "(n)",
        "explanation": "惟 (Omega) representa la cota inferior o el mejor caso del tiempo de ejecuci贸n. O (Big-O) representa la cota superior o el peor caso.  (Theta) representa la cota ajustada, que se da cuando las cotas inferior y superior coinciden, describiendo el caso promedio de forma precisa."
      },
      "algorithm_name": "Factorial Iterativo",
      "algorithm_category": "Iteraci贸n Simple",
      "equation": "T(n) = c1 + c4 + 危(i=1 to n) (c2 + c3)",
      "method_solution": "An谩lisis de Sumatorias",
      "solution_equation": "O(n)",
      "explain_solution_steps": [
        "El tiempo de ejecuci贸n total T(n) es la suma de los costos de cada l铆nea.",
        "T(n) = (costo l铆nea 1) + (costo l铆nea 2) + (costo l铆nea 3) + (costo l铆nea 4)",
        "T(n) = (c1 * 1) + (c2 * n) + (c3 * n) + (c4 * 1)",
        "Agrupamos los t茅rminos por su dependencia de n: T(n) = (c2 + c3) * n + (c1 + c4)",
        "Definimos nuevas constantes para simplificar: C_a = c2 + c3 y C_b = c1 + c4.",
        "La ecuaci贸n se convierte en: T(n) = C_a * n + C_b. Esta es una funci贸n lineal de n.",
        "En el an谩lisis asint贸tico, nos centramos en el t茅rmino de mayor orden y despreciamos las constantes. El t茅rmino dominante es n.",
        "Por lo tanto, la complejidad del algoritmo es directamente proporcional a n."
      ],
      "diagrams": null,
      "extra": {
        "pseudocode": "factorial(n)\nbegin\n    f 〃 1\n    for i 〃 1 to n do\n    begin\n        f 〃 f * i\n    end\n    return f\nend",
        "analysis_complete": true
      }
    }
  }
}