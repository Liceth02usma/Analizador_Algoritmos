{
  "metadata": {
    "algorithm_name": "Quicksort",
    "compared_at": "2025-12-05T22:32:16.164255",
    "specialized_timestamp": "2025-12-05T22:30:58.064699"
  },
  "tokens_comparison": {
    "specialized": {
      "input": 0,
      "output": 0,
      "total": 0
    },
    "complete": {
      "input": 1546,
      "output": 2885,
      "total": 4431
    },
    "difference": {
      "input": -1546,
      "output": -2885,
      "total": -4431
    },
    "percentage_difference": {
      "total": -100.0
    }
  },
  "complexity_comparison": {
    "specialized": "O(n^2)",
    "complete": "N/A",
    "match": false
  },
  "methods_comparison": {
    "specialized": [
      "An√°lisis especializado multi-agente"
    ],
    "complete": "An√°lisis completo sin especializaci√≥n"
  },
  "detail_comparison": {
    "specialized_steps": 0,
    "complete_steps": 0,
    "specialized_cases": 0,
    "complete_cases": 1
  },
  "execution_time": {
    "specialized": 0,
    "complete": 23.22358727455139,
    "difference": -23.22358727455139,
    "percentage_difference": -100.0
  },
  "complete_agent_analysis": {
    "algorithm_name": "Quicksort",
    "algorithm_purpose": "No especificado",
    "algorithm_category": "Divide y Conquista",
    "algorithm_type": "iterative",
    "equation": "Caso Peor: T(n) = T(n-1) + T(0) + Œò(n) = T(n-1) + Œò(n), con T(1) = c. Caso Promedio/Mejor: T(n) = 2T(n/2) + Œò(n), con T(1) = c.",
    "final_complexity": "N/A",
    "asymptotic_best": "N/A",
    "asymptotic_worst": "N/A",
    "asymptotic_average": "N/A",
    "solution_method": "An√°lisis completo sin especializaci√≥n",
    "solution_steps": [],
    "steps_count": 0,
    "line_by_line_analysis": [],
    "execution_time": 23.22358727455139,
    "tokens_used": 4431
  },
  "full_results": {
    "specialized": {
      "type": "Recursivo",
      "code_explain": "El mejor caso ocurre cuando la funci√≥n `partition` siempre selecciona un pivote que divide el arreglo en dos subarreglos de tama√±o aproximadamente igual (el pivote es la mediana).",
      "complexity_line_to_line": "=== MEJOR CASO ===\nquicksort(arr, low, high)\nbegin\n    if (low < high) then  // c1\n    begin\n        pi ü°® CALL partition(arr, low, high)  // c_p * n\n        CALL quicksort(arr, low, pi - 1)  // T(n/2)\n        CALL quicksort(arr, pi + 1, high)  // T(n/2)\n    end\nend\n\n=== PEOR CASO ===\nquicksort(arr, low, high)\nbegin\n    if (low < high) then  // c1\n    begin\n        pi ü°® CALL partition(arr, low, high)  // c_p * n\n        CALL quicksort(arr, low, pi - 1)  // T(0) (si el pivote es el primer elemento)\n        CALL quicksort(arr, pi + 1, high)  // T(n-1) (si el pivote es el primer elemento)\n    end\nend\n\n=== CASO PROMEDIO ===\nquicksort(arr, low, high)\nbegin\n    if (low < high) then  // c1\n    begin\n        pi ü°® CALL partition(arr, low, high)  // c_p * n\n        CALL quicksort(arr, low, pi - 1)  // T(n/k) (e.g., T(n/4))\n        CALL quicksort(arr, pi + 1, high)  // T(n - n/k) (e.g., T(3n/4))\n    end\nend",
      "explain_complexity": "Mejor caso: La relaci√≥n de recurrencia para el mejor caso es T(n) = 2 * T(n/2) + c_p * n + c1. Aqu√≠, `c_p * n` representa el costo de la funci√≥n `partition` que recorre el subarreglo de tama√±o `n`. Resolviendo esta recurrencia (por ejemplo, usando el Teorema Maestro), obtenemos una complejidad de O(n log n).\n\nPeor caso: La relaci√≥n de recurrencia para el peor caso es T(n) = T(n-1) + T(0) + c_p * n + c1. Asumiendo que T(0) es una constante, la recurrencia se simplifica a T(n) = T(n-1) + c_p * n + C. Resolviendo esta recurrencia por sustituci√≥n, se obtiene una suma de `n` t√©rminos, donde el t√©rmino dominante es `n^2`. Por lo tanto, la complejidad es O(n^2).\n\nCaso promedio: La relaci√≥n de recurrencia para el caso promedio puede ser representada como T(n) = T(n/k) + T(n - n/k) + c_p * n + c1, donde `k` es una constante (e.g., T(n) = T(n/4) + T(3n/4) + c_p * n + c1). Aunque la derivaci√≥n formal es m√°s compleja, esta recurrencia tambi√©n se resuelve a una complejidad de O(n log n).",
      "asymptotic_notation": {
        "explanation": "El algoritmo Quicksort tiene una complejidad temporal de O(n^2) en el peor caso.",
        "best": "Œ©(log n)",
        "worst": "O(n^2)",
        "average": "Œò(n)"
      },
      "algorithm_name": "Quicksort",
      "algorithm_category": "Recursivo",
      "equation": [
        "T(n)=2T(n/2)+n, T(1)=1",
        "T(n)=T(n-1)+n, T(1)=1",
        "T(n) = T(n-1) + (2n + 5)/3"
      ],
      "method_solution": [
        "master_theorem",
        "equation_characteristics",
        "intelligent_substitution"
      ],
      "solution_equation": [
        "n log n",
        "n^2",
        "O(n¬≤)"
      ],
      "explain_solution_steps": [
        {
          "case_type": "best_case",
          "equation": "T(n)=2T(n/2)+n, T(1)=1",
          "original_equation": "T(n)=2T(n/2)+n, T(1)=1",
          "simplification": null,
          "method": "master_theorem",
          "method_enum": "master_theorem",
          "complexity": "n log n",
          "steps": [
            "**Paso 1 - Par√°metros:**",
            " a = 2, b = 2",
            " f(n) = n",
            "",
            "**Paso 2 - Exponente Cr√≠tico:**",
            " log_2(2) ‚âà n^1",
            "",
            "**Paso 3 - An√°lisis de L√≠mite (SymPy):**",
            " f(n) crece a la misma velocidad que n^E",
            "",
            "**Paso 4 - Conclusi√≥n:**",
            " Aplica **Caso 2**",
            " T√©rmino dominante: n log n"
          ],
          "explanation": "1.  **Identificaci√≥n de Par√°metros:**\n    *   Tenemos a = 2 (dos subproblemas).\n    *   Tenemos b = 2 (cada subproblema es de tama√±o n/2).\n    *   Tenemos f(n) = n (el trabajo adicional fuera de las llamadas recursivas).\n\n2.  **C√°lculo del Exponente Cr√≠tico (E):**\n    *   Calculamos E = log_b a = log_2 2.\n    *   Esto nos da E = 1.\n    *   Por lo tanto, el t√©rmino de comparaci√≥n es n^E = n^1 = n.\n\n3.  **C√°lculo e Interpretaci√≥n del L√≠mite:**\n    *   Ahora comparamos f(n) con n^E calculando el l√≠mite:\n        L = lim (n -> ‚àû) [f(n) / n^E]\n        L = lim (n -> ‚àû) [n / n^1]\n        L = lim (n -> ‚àû) [1]\n        L = 1\n    *   Dado que el l√≠mite es una constante positiva (1), esto significa que f(n) y n^E crecen a la misma velocidad asint√≥ticamente.\n\n4.  **Conclusi√≥n del Caso y Complejidad:**\n    *   Esta situaci√≥n corresponde al **Caso 2** del Teorema Maestro.\n    *   Cuando f(n) y n^E son asint√≥ticamente iguales, la complejidad se determina multiplicando n^E por un factor logar√≠tmico.\n    *   La complejidad final es **n log n**.",
          "details": {
            "complexity": "n log n",
            "steps": [
              "**Paso 1 - Par√°metros:**",
              " a = 2, b = 2",
              " f(n) = n",
              "",
              "**Paso 2 - Exponente Cr√≠tico:**",
              " log_2(2) ‚âà n^1",
              "",
              "**Paso 3 - An√°lisis de L√≠mite (SymPy):**",
              " f(n) crece a la misma velocidad que n^E",
              "",
              "**Paso 4 - Conclusi√≥n:**",
              " Aplica **Caso 2**",
              " T√©rmino dominante: n log n"
            ],
            "explanation": "1.  **Identificaci√≥n de Par√°metros:**\n    *   Tenemos a = 2 (dos subproblemas).\n    *   Tenemos b = 2 (cada subproblema es de tama√±o n/2).\n    *   Tenemos f(n) = n (el trabajo adicional fuera de las llamadas recursivas).\n\n2.  **C√°lculo del Exponente Cr√≠tico (E):**\n    *   Calculamos E = log_b a = log_2 2.\n    *   Esto nos da E = 1.\n    *   Por lo tanto, el t√©rmino de comparaci√≥n es n^E = n^1 = n.\n\n3.  **C√°lculo e Interpretaci√≥n del L√≠mite:**\n    *   Ahora comparamos f(n) con n^E calculando el l√≠mite:\n        L = lim (n -> ‚àû) [f(n) / n^E]\n        L = lim (n -> ‚àû) [n / n^1]\n        L = lim (n -> ‚àû) [1]\n        L = 1\n    *   Dado que el l√≠mite es una constante positiva (1), esto significa que f(n) y n^E crecen a la misma velocidad asint√≥ticamente.\n\n4.  **Conclusi√≥n del Caso y Complejidad:**\n    *   Esta situaci√≥n corresponde al **Caso 2** del Teorema Maestro.\n    *   Cuando f(n) y n^E son asint√≥ticamente iguales, la complejidad se determina multiplicando n^E por un factor logar√≠tmico.\n    *   La complejidad final es **n log n**.",
            "applicable": true,
            "method": "Teorema Maestro",
            "case": "Caso 2",
            "a": 2,
            "b": 2,
            "log_b_a": "n^1"
          },
          "classification_confidence": 0.95,
          "classification_reasoning": "Ecuaci√≥n en forma T(n) = aT(n/2) + f(n). Divide el problema en 1 subproblema(s) de tama√±o n/2. Trabajo adicional: =+n,=1. El Teorema Maestro es el m√©todo √≥ptimo."
        },
        {
          "case_type": "worst_case",
          "equation": "T(n)=T(n-1)+n, T(1)=1",
          "original_equation": "T(n)=T(n-1)+n, T(1)=1",
          "simplification": null,
          "method": "equation_characteristics",
          "method_enum": "equation_characteristics",
          "complexity": "n^2",
          "steps": [
            "**Soluci√≥n Exacta (SymPy):** n(n+1)/2",
            "**Crecimiento asint√≥tico:** n^2",
            "",
            "**Explicaci√≥n Te√≥rica:**",
            "Aunque la herramienta SymPy report√≥ un error en su c√°lculo simb√≥lico, el procedimiento est√°ndar para resolver la recurrencia lineal no homog√©nea T(n) = T(n-1) + n con la condici√≥n inicial T(1) = 1 es el siguiente, y la soluci√≥n exacta que se obtiene es T(n) = n(n+1)/2.\n\n**Paso 1: Identificar la forma de la recurrencia.**\nLa recurrencia T(n) = T(n-1) + n es una recurrencia lineal de primer orden no homog√©nea, ya que tiene un t√©rmino T(n-1) y un t√©rmino no constante 'n'.\n\n**Paso 2: Resolver la parte homog√©nea.**\nConsideramos la parte homog√©nea de la recurrencia: T(n) = T(n-1).\nPara encontrar la soluci√≥n homog√©nea T_h(n), formamos la ecuaci√≥n caracter√≠stica reemplazando T(n) por r^n y T(n-1) por r^(n-1):\nr^n = r^(n-1)\nDividiendo por r^(n-1) (asumiendo r ‚â† 0), obtenemos la ecuaci√≥n caracter√≠stica:\nr - 1 = 0\n\n**Paso 3: Encontrar las ra√≠ces de la ecuaci√≥n caracter√≠stica.**\nLa √∫nica ra√≠z de la ecuaci√≥n caracter√≠stica r - 1 = 0 es:\nr_1 = 1\n\n**Paso 4: Formar la soluci√≥n homog√©nea.**\nDado que tenemos una ra√≠z real y no repetida (r_1 = 1), la soluci√≥n homog√©nea es de la forma:\nT_h(n) = C * (r_1)^n = C * 1^n = C\nDonde C es una constante.\n\n**Paso 5: Encontrar la soluci√≥n particular.**\nEl t√©rmino no homog√©neo es f(n) = n. Como f(n) es un polinomio de grado 1, y la ra√≠z r=1 de la ecuaci√≥n caracter√≠stica tiene multiplicidad 1, la forma de la soluci√≥n particular T_p(n) debe ser un polinomio de grado 1 multiplicado por n (debido a la coincidencia con la ra√≠z). Es decir, T_p(n) = n * (An + B) = An^2 + Bn.\n\nSustituimos T_p(n) en la recurrencia original T(n) = T(n-1) + n:\nAn^2 + Bn = A(n-1)^2 + B(n-1) + n\nAn^2 + Bn = A(n^2 - 2n + 1) + Bn - B + n\nAn^2 + Bn = An^2 - 2An + A + Bn - B + n\n\nRestando An^2 + Bn de ambos lados:\n0 = -2An + A - B + n\n\nAgrupando t√©rminos por potencias de n:\n0 = (-2A + 1)n + (A - B)\n\nPara que esta ecuaci√≥n sea v√°lida para todo n, los coeficientes de cada potencia de n deben ser cero:\n1) Coeficiente de n: -2A + 1 = 0  =>  2A = 1  =>  A = 1/2\n2) T√©rmino constante: A - B = 0  =>  B = A  =>  B = 1/2\n\nPor lo tanto, la soluci√≥n particular es:\nT_p(n) = (1/2)n^2 + (1/2)n = n(n+1)/2\n\n**Paso 6: Formar la soluci√≥n general.**\nLa soluci√≥n general es la suma de la soluci√≥n homog√©nea y la soluci√≥n particular:\nT(n) = T_h(n) + T_p(n)\nT(n) = C + n(n+1)/2\n\n**Paso 7: Aplicar la condici√≥n inicial.**\nUsamos la condici√≥n inicial T(1) = 1 para encontrar el valor de la constante C:\nT(1) = C + 1(1+1)/2\n1 = C + 1(2)/2\n1 = C + 1\nC = 0\n\n**Paso 8: Escribir la soluci√≥n final exacta.**\nSustituyendo C = 0 en la soluci√≥n general, obtenemos la soluci√≥n exacta de la recurrencia:\nT(n) = n(n+1)/2\n\n**Paso 9: Determinar la complejidad (t√©rmino dominante).**\nEl t√©rmino dominante en la soluci√≥n T(n) = n(n+1)/2 = (n^2 + n)/2 es n^2.\n"
          ],
          "explanation": "Aunque la herramienta SymPy report√≥ un error en su c√°lculo simb√≥lico, el procedimiento est√°ndar para resolver la recurrencia lineal no homog√©nea T(n) = T(n-1) + n con la condici√≥n inicial T(1) = 1 es el siguiente, y la soluci√≥n exacta que se obtiene es T(n) = n(n+1)/2.\n\n**Paso 1: Identificar la forma de la recurrencia.**\nLa recurrencia T(n) = T(n-1) + n es una recurrencia lineal de primer orden no homog√©nea, ya que tiene un t√©rmino T(n-1) y un t√©rmino no constante 'n'.\n\n**Paso 2: Resolver la parte homog√©nea.**\nConsideramos la parte homog√©nea de la recurrencia: T(n) = T(n-1).\nPara encontrar la soluci√≥n homog√©nea T_h(n), formamos la ecuaci√≥n caracter√≠stica reemplazando T(n) por r^n y T(n-1) por r^(n-1):\nr^n = r^(n-1)\nDividiendo por r^(n-1) (asumiendo r ‚â† 0), obtenemos la ecuaci√≥n caracter√≠stica:\nr - 1 = 0\n\n**Paso 3: Encontrar las ra√≠ces de la ecuaci√≥n caracter√≠stica.**\nLa √∫nica ra√≠z de la ecuaci√≥n caracter√≠stica r - 1 = 0 es:\nr_1 = 1\n\n**Paso 4: Formar la soluci√≥n homog√©nea.**\nDado que tenemos una ra√≠z real y no repetida (r_1 = 1), la soluci√≥n homog√©nea es de la forma:\nT_h(n) = C * (r_1)^n = C * 1^n = C\nDonde C es una constante.\n\n**Paso 5: Encontrar la soluci√≥n particular.**\nEl t√©rmino no homog√©neo es f(n) = n. Como f(n) es un polinomio de grado 1, y la ra√≠z r=1 de la ecuaci√≥n caracter√≠stica tiene multiplicidad 1, la forma de la soluci√≥n particular T_p(n) debe ser un polinomio de grado 1 multiplicado por n (debido a la coincidencia con la ra√≠z). Es decir, T_p(n) = n * (An + B) = An^2 + Bn.\n\nSustituimos T_p(n) en la recurrencia original T(n) = T(n-1) + n:\nAn^2 + Bn = A(n-1)^2 + B(n-1) + n\nAn^2 + Bn = A(n^2 - 2n + 1) + Bn - B + n\nAn^2 + Bn = An^2 - 2An + A + Bn - B + n\n\nRestando An^2 + Bn de ambos lados:\n0 = -2An + A - B + n\n\nAgrupando t√©rminos por potencias de n:\n0 = (-2A + 1)n + (A - B)\n\nPara que esta ecuaci√≥n sea v√°lida para todo n, los coeficientes de cada potencia de n deben ser cero:\n1) Coeficiente de n: -2A + 1 = 0  =>  2A = 1  =>  A = 1/2\n2) T√©rmino constante: A - B = 0  =>  B = A  =>  B = 1/2\n\nPor lo tanto, la soluci√≥n particular es:\nT_p(n) = (1/2)n^2 + (1/2)n = n(n+1)/2\n\n**Paso 6: Formar la soluci√≥n general.**\nLa soluci√≥n general es la suma de la soluci√≥n homog√©nea y la soluci√≥n particular:\nT(n) = T_h(n) + T_p(n)\nT(n) = C + n(n+1)/2\n\n**Paso 7: Aplicar la condici√≥n inicial.**\nUsamos la condici√≥n inicial T(1) = 1 para encontrar el valor de la constante C:\nT(1) = C + 1(1+1)/2\n1 = C + 1(2)/2\n1 = C + 1\nC = 0\n\n**Paso 8: Escribir la soluci√≥n final exacta.**\nSustituyendo C = 0 en la soluci√≥n general, obtenemos la soluci√≥n exacta de la recurrencia:\nT(n) = n(n+1)/2\n\n**Paso 9: Determinar la complejidad (t√©rmino dominante).**\nEl t√©rmino dominante en la soluci√≥n T(n) = n(n+1)/2 = (n^2 + n)/2 es n^2.\n",
          "details": {
            "complexity": "n^2",
            "steps": [
              "**Soluci√≥n Exacta (SymPy):** n(n+1)/2",
              "**Crecimiento asint√≥tico:** n^2",
              "",
              "**Explicaci√≥n Te√≥rica:**",
              "Aunque la herramienta SymPy report√≥ un error en su c√°lculo simb√≥lico, el procedimiento est√°ndar para resolver la recurrencia lineal no homog√©nea T(n) = T(n-1) + n con la condici√≥n inicial T(1) = 1 es el siguiente, y la soluci√≥n exacta que se obtiene es T(n) = n(n+1)/2.\n\n**Paso 1: Identificar la forma de la recurrencia.**\nLa recurrencia T(n) = T(n-1) + n es una recurrencia lineal de primer orden no homog√©nea, ya que tiene un t√©rmino T(n-1) y un t√©rmino no constante 'n'.\n\n**Paso 2: Resolver la parte homog√©nea.**\nConsideramos la parte homog√©nea de la recurrencia: T(n) = T(n-1).\nPara encontrar la soluci√≥n homog√©nea T_h(n), formamos la ecuaci√≥n caracter√≠stica reemplazando T(n) por r^n y T(n-1) por r^(n-1):\nr^n = r^(n-1)\nDividiendo por r^(n-1) (asumiendo r ‚â† 0), obtenemos la ecuaci√≥n caracter√≠stica:\nr - 1 = 0\n\n**Paso 3: Encontrar las ra√≠ces de la ecuaci√≥n caracter√≠stica.**\nLa √∫nica ra√≠z de la ecuaci√≥n caracter√≠stica r - 1 = 0 es:\nr_1 = 1\n\n**Paso 4: Formar la soluci√≥n homog√©nea.**\nDado que tenemos una ra√≠z real y no repetida (r_1 = 1), la soluci√≥n homog√©nea es de la forma:\nT_h(n) = C * (r_1)^n = C * 1^n = C\nDonde C es una constante.\n\n**Paso 5: Encontrar la soluci√≥n particular.**\nEl t√©rmino no homog√©neo es f(n) = n. Como f(n) es un polinomio de grado 1, y la ra√≠z r=1 de la ecuaci√≥n caracter√≠stica tiene multiplicidad 1, la forma de la soluci√≥n particular T_p(n) debe ser un polinomio de grado 1 multiplicado por n (debido a la coincidencia con la ra√≠z). Es decir, T_p(n) = n * (An + B) = An^2 + Bn.\n\nSustituimos T_p(n) en la recurrencia original T(n) = T(n-1) + n:\nAn^2 + Bn = A(n-1)^2 + B(n-1) + n\nAn^2 + Bn = A(n^2 - 2n + 1) + Bn - B + n\nAn^2 + Bn = An^2 - 2An + A + Bn - B + n\n\nRestando An^2 + Bn de ambos lados:\n0 = -2An + A - B + n\n\nAgrupando t√©rminos por potencias de n:\n0 = (-2A + 1)n + (A - B)\n\nPara que esta ecuaci√≥n sea v√°lida para todo n, los coeficientes de cada potencia de n deben ser cero:\n1) Coeficiente de n: -2A + 1 = 0  =>  2A = 1  =>  A = 1/2\n2) T√©rmino constante: A - B = 0  =>  B = A  =>  B = 1/2\n\nPor lo tanto, la soluci√≥n particular es:\nT_p(n) = (1/2)n^2 + (1/2)n = n(n+1)/2\n\n**Paso 6: Formar la soluci√≥n general.**\nLa soluci√≥n general es la suma de la soluci√≥n homog√©nea y la soluci√≥n particular:\nT(n) = T_h(n) + T_p(n)\nT(n) = C + n(n+1)/2\n\n**Paso 7: Aplicar la condici√≥n inicial.**\nUsamos la condici√≥n inicial T(1) = 1 para encontrar el valor de la constante C:\nT(1) = C + 1(1+1)/2\n1 = C + 1(2)/2\n1 = C + 1\nC = 0\n\n**Paso 8: Escribir la soluci√≥n final exacta.**\nSustituyendo C = 0 en la soluci√≥n general, obtenemos la soluci√≥n exacta de la recurrencia:\nT(n) = n(n+1)/2\n\n**Paso 9: Determinar la complejidad (t√©rmino dominante).**\nEl t√©rmino dominante en la soluci√≥n T(n) = n(n+1)/2 = (n^2 + n)/2 es n^2.\n"
            ],
            "explanation": "Aunque la herramienta SymPy report√≥ un error en su c√°lculo simb√≥lico, el procedimiento est√°ndar para resolver la recurrencia lineal no homog√©nea T(n) = T(n-1) + n con la condici√≥n inicial T(1) = 1 es el siguiente, y la soluci√≥n exacta que se obtiene es T(n) = n(n+1)/2.\n\n**Paso 1: Identificar la forma de la recurrencia.**\nLa recurrencia T(n) = T(n-1) + n es una recurrencia lineal de primer orden no homog√©nea, ya que tiene un t√©rmino T(n-1) y un t√©rmino no constante 'n'.\n\n**Paso 2: Resolver la parte homog√©nea.**\nConsideramos la parte homog√©nea de la recurrencia: T(n) = T(n-1).\nPara encontrar la soluci√≥n homog√©nea T_h(n), formamos la ecuaci√≥n caracter√≠stica reemplazando T(n) por r^n y T(n-1) por r^(n-1):\nr^n = r^(n-1)\nDividiendo por r^(n-1) (asumiendo r ‚â† 0), obtenemos la ecuaci√≥n caracter√≠stica:\nr - 1 = 0\n\n**Paso 3: Encontrar las ra√≠ces de la ecuaci√≥n caracter√≠stica.**\nLa √∫nica ra√≠z de la ecuaci√≥n caracter√≠stica r - 1 = 0 es:\nr_1 = 1\n\n**Paso 4: Formar la soluci√≥n homog√©nea.**\nDado que tenemos una ra√≠z real y no repetida (r_1 = 1), la soluci√≥n homog√©nea es de la forma:\nT_h(n) = C * (r_1)^n = C * 1^n = C\nDonde C es una constante.\n\n**Paso 5: Encontrar la soluci√≥n particular.**\nEl t√©rmino no homog√©neo es f(n) = n. Como f(n) es un polinomio de grado 1, y la ra√≠z r=1 de la ecuaci√≥n caracter√≠stica tiene multiplicidad 1, la forma de la soluci√≥n particular T_p(n) debe ser un polinomio de grado 1 multiplicado por n (debido a la coincidencia con la ra√≠z). Es decir, T_p(n) = n * (An + B) = An^2 + Bn.\n\nSustituimos T_p(n) en la recurrencia original T(n) = T(n-1) + n:\nAn^2 + Bn = A(n-1)^2 + B(n-1) + n\nAn^2 + Bn = A(n^2 - 2n + 1) + Bn - B + n\nAn^2 + Bn = An^2 - 2An + A + Bn - B + n\n\nRestando An^2 + Bn de ambos lados:\n0 = -2An + A - B + n\n\nAgrupando t√©rminos por potencias de n:\n0 = (-2A + 1)n + (A - B)\n\nPara que esta ecuaci√≥n sea v√°lida para todo n, los coeficientes de cada potencia de n deben ser cero:\n1) Coeficiente de n: -2A + 1 = 0  =>  2A = 1  =>  A = 1/2\n2) T√©rmino constante: A - B = 0  =>  B = A  =>  B = 1/2\n\nPor lo tanto, la soluci√≥n particular es:\nT_p(n) = (1/2)n^2 + (1/2)n = n(n+1)/2\n\n**Paso 6: Formar la soluci√≥n general.**\nLa soluci√≥n general es la suma de la soluci√≥n homog√©nea y la soluci√≥n particular:\nT(n) = T_h(n) + T_p(n)\nT(n) = C + n(n+1)/2\n\n**Paso 7: Aplicar la condici√≥n inicial.**\nUsamos la condici√≥n inicial T(1) = 1 para encontrar el valor de la constante C:\nT(1) = C + 1(1+1)/2\n1 = C + 1(2)/2\n1 = C + 1\nC = 0\n\n**Paso 8: Escribir la soluci√≥n final exacta.**\nSustituyendo C = 0 en la soluci√≥n general, obtenemos la soluci√≥n exacta de la recurrencia:\nT(n) = n(n+1)/2\n\n**Paso 9: Determinar la complejidad (t√©rmino dominante).**\nEl t√©rmino dominante en la soluci√≥n T(n) = n(n+1)/2 = (n^2 + n)/2 es n^2.\n",
            "applicable": true,
            "method": "Ecuaci√≥n Caracter√≠stica",
            "final_solution": "n(n+1)/2"
          },
          "classification_confidence": 0.9,
          "classification_reasoning": "Recurrencia lineal de orden superior. T√©rminos: T(n-1). Trabajo adicional: =+n,=1. La ecuaci√≥n caracter√≠stica es ideal para resolver este tipo de recurrencia.."
        },
        {
          "case_type": "average_case",
          "equation": "T(n) = T(n-1) + (2n + 5)/3",
          "original_equation": "T(n)=(2/n)√óŒ£[i=1 to n]T(i)+n, donde T(i)=T(i-1)+i, T(1)=1",
          "simplification": {
            "original": "T(n)=(2/n)√óŒ£[i=1 to n]T(i)+n, donde T(i)=T(i-1)+i, T(1)=1",
            "simplified": "T(n) = T(n-1) + (2n + 5)/3",
            "steps": [
              "Paso 1: Resolvemos T_int(i). La recurrencia T(i) = T(i-1) + i con T(1)=1 se resuelve como la suma de los primeros i n√∫meros naturales, T_int(i) = i(i+1)/2.",
              "Paso 2: Evaluamos la sumatoria S(n) = Œ£[i=1 to n] T_int(i). Sustituimos T_int(i): S(n) = Œ£[i=1 to n] i(i+1)/2 = (1/2) * Œ£[i=1 to n] (i^2 + i). Usando las f√≥rmulas de sumatoria: S(n) = (1/2) * [n(n+1)(2n+1)/6 + n(n+1)/2] = (1/2) * n(n+1) * [(2n+1)/6 + 3/6] = (1/2) * n(n+1) * (2n+4)/6 = (1/2) * n(n+1) * (n+2)/3 = n(n+1)(n+2)/6.",
              "Paso 3: Obtenemos la forma expl√≠cita de T(n). Sustituimos S(n) en la ecuaci√≥n original: T(n) = (2/n) * [n(n+1)(n+2)/6] + n = (n+1)(n+2)/3 + n = (n^2 + 3n + 2)/3 + 3n/3 = (n^2 + 6n + 2)/3.",
              "Paso 4: Derivamos la recurrencia final g'(n) = T(n) - T(n-1). T(n-1) = ((n-1)^2 + 6(n-1) + 2)/3 = (n^2 - 2n + 1 + 6n - 6 + 2)/3 = (n^2 + 4n - 3)/3. Restamos: g'(n) = (n^2 + 6n + 2)/3 - (n^2 + 4n - 3)/3 = (n^2 + 6n + 2 - n^2 - 4n + 3)/3 = (2n + 5)/3."
            ],
            "explicit_form": "T(n) = (n^2 + 6n + 2)/3",
            "summation_resolved": "n(n+1)(n+2)/6",
            "confidence": 1.0,
            "pattern_type": "quadratic"
          },
          "method": "intelligent_substitution",
          "method_enum": "intelligent_substitution",
          "complexity": "O(n¬≤)",
          "steps": [
            "**Paso 1 - Expandir la recurrencia iterativamente:**",
            "   T(n) = T(n-1) + (2n + 5)/3",
            "   T(n) = T(n-2) + (2n + 3)/3 + (2n + 5)/3",
            "   T(n) = T(n-3) + (2n + 1)/3 + (2n + 3)/3 + (2n + 5)/3",
            "   T(n) = T(n-4) + (2n - 1)/3 + (2n + 1)/3 + (2n + 3)/3 + (2n + 5)/3",
            "",
            "**Paso 2 - Identificar el patr√≥n general:**",
            "   Despu√©s de k sustituciones:",
            "   T(n-k) + (1/3) * Œ£[i=n-k+1 to n] (2i + 5)",
            "",
            "**Paso 3 - Sustituir el caso base:**",
            "   Para el caso base T(1), tenemos n - k = 1, lo que implica k = n - 1. Sustituyendo k en el patr√≥n general: T(n) = T(1) + (1/3) * Œ£[i=2 to n] (2i + 5)",
            "",
            "**Paso 4 - Forma cerrada:**",
            "   T(n) = (n¬≤ + 6n - 4)/3",
            "",
            "**Paso 5 - Complejidad final:**",
            "   O(n¬≤)"
          ],
          "explanation": "**Paso 1: Expandir la recurrencia iterativamente**\nLa ecuaci√≥n de recurrencia dada es T(n) = T(n-1) + (2n + 5)/3.\n\n1.  **Primera expansi√≥n:**\n    T(n) = T(n-1) + (2n + 5)/3\n\n2.  **Segunda expansi√≥n:** Sustituimos T(n-1) = T(n-2) + (2(n-1) + 5)/3\n    T(n) = [T(n-2) + (2(n-1) + 5)/3] + (2n + 5)/3\n    T(n) = T(n-2) + (2n - 2 + 5)/3 + (2n + 5)/3\n    T(n) = T(n-2) + (2n + 3)/3 + (2n + 5)/3\n\n3.  **Tercera expansi√≥n:** Sustituimos T(n-2) = T(n-3) + (2(n-2) + 5)/3\n    T(n) = [T(n-3) + (2(n-2) + 5)/3] + (2n + 3)/3 + (2n + 5)/3\n    T(n) = T(n-3) + (2n - 4 + 5)/3 + (2n + 3)/3 + (2n + 5)/3\n    T(n) = T(n-3) + (2n + 1)/3 + (2n + 3)/3 + (2n + 5)/3\n\n4.  **Cuarta expansi√≥n:** Sustituimos T(n-3) = T(n-4) + (2(n-3) + 5)/3\n    T(n) = [T(n-4) + (2(n-3) + 5)/3] + (2n + 1)/3 + (2n + 3)/3 + (2n + 5)/3\n    T(n) = T(n-4) + (2n - 6 + 5)/3 + (2n + 1)/3 + (2n + 3)/3 + (2n + 5)/3\n    T(n) = T(n-4) + (2n - 1)/3 + (2n + 1)/3 + (2n + 3)/3 + (2n + 5)/3\n\n**Paso 2: Identificar el patr√≥n general**\nDespu√©s de `k` sustituciones, la recurrencia toma la forma:\nT(n) = T(n-k) + (1/3) * [ (2(n-k+1) + 5) + (2(n-k+2) + 5) + ... + (2n + 5) ]\nEsto se puede expresar como una sumatoria:\nT(n) = T(n-k) + (1/3) * Œ£[i=n-k+1 to n] (2i + 5)\n\n**Paso 3: Determinar cu√°ndo se alcanza el caso base**\nAsumiendo que el caso base es T(1), necesitamos que el argumento de T sea 1:\nn - k = 1\nPor lo tanto, k = n - 1.\n\n**Paso 4: Sustituir el caso base y simplificar**\nSustituimos k = n-1 en la expresi√≥n general:\nT(n) = T(n-(n-1)) + (1/3) * Œ£[i=n-(n-1)+1 to n] (2i + 5)\nT(n) = T(1) + (1/3) * Œ£[i=2 to n] (2i + 5)\n\nPara simplificar la sumatoria Œ£[i=2 to n] (2i + 5):\nŒ£[i=2 to n] (2i + 5) = Œ£[i=1 to n] (2i + 5) - (2(1) + 5)\n                      = Œ£[i=1 to n] (2i + 5) - 7\n\nAhora, evaluamos Œ£[i=1 to n] (2i + 5):\nŒ£[i=1 to n] (2i + 5) = Œ£[i=1 to n] 2i + Œ£[i=1 to n] 5\n                      = 2 * Œ£[i=1 to n] i + 5 * n\n                      = 2 * [n(n+1)/2] + 5n\n                      = n(n+1) + 5n\n                      = n¬≤ + n + 5n\n                      = n¬≤ + 6n\n\nSustituyendo esto de nuevo en la expresi√≥n para T(n):\nT(n) = T(1) + (1/3) * [ (n¬≤ + 6n) - 7 ]\n\nAsumiendo un caso base T(1) = 1 (si no se especifica lo contrario):\nT(n) = 1 + (n¬≤ + 6n - 7)/3\nT(n) = (3 + n¬≤ + 6n - 7)/3\nT(n) = (n¬≤ + 6n - 4)/3\n\n**Paso 5: Expresar forma cerrada y complejidad**\nLa forma cerrada de la soluci√≥n es T(n) = (n¬≤ + 6n - 4)/3.\nEl t√©rmino dominante es n¬≤, por lo tanto, la complejidad asint√≥tica es O(n¬≤).",
          "details": {
            "complexity": "O(n¬≤)",
            "steps": [
              "**Paso 1 - Expandir la recurrencia iterativamente:**",
              "   T(n) = T(n-1) + (2n + 5)/3",
              "   T(n) = T(n-2) + (2n + 3)/3 + (2n + 5)/3",
              "   T(n) = T(n-3) + (2n + 1)/3 + (2n + 3)/3 + (2n + 5)/3",
              "   T(n) = T(n-4) + (2n - 1)/3 + (2n + 1)/3 + (2n + 3)/3 + (2n + 5)/3",
              "",
              "**Paso 2 - Identificar el patr√≥n general:**",
              "   Despu√©s de k sustituciones:",
              "   T(n-k) + (1/3) * Œ£[i=n-k+1 to n] (2i + 5)",
              "",
              "**Paso 3 - Sustituir el caso base:**",
              "   Para el caso base T(1), tenemos n - k = 1, lo que implica k = n - 1. Sustituyendo k en el patr√≥n general: T(n) = T(1) + (1/3) * Œ£[i=2 to n] (2i + 5)",
              "",
              "**Paso 4 - Forma cerrada:**",
              "   T(n) = (n¬≤ + 6n - 4)/3",
              "",
              "**Paso 5 - Complejidad final:**",
              "   O(n¬≤)"
            ],
            "explanation": "**Paso 1: Expandir la recurrencia iterativamente**\nLa ecuaci√≥n de recurrencia dada es T(n) = T(n-1) + (2n + 5)/3.\n\n1.  **Primera expansi√≥n:**\n    T(n) = T(n-1) + (2n + 5)/3\n\n2.  **Segunda expansi√≥n:** Sustituimos T(n-1) = T(n-2) + (2(n-1) + 5)/3\n    T(n) = [T(n-2) + (2(n-1) + 5)/3] + (2n + 5)/3\n    T(n) = T(n-2) + (2n - 2 + 5)/3 + (2n + 5)/3\n    T(n) = T(n-2) + (2n + 3)/3 + (2n + 5)/3\n\n3.  **Tercera expansi√≥n:** Sustituimos T(n-2) = T(n-3) + (2(n-2) + 5)/3\n    T(n) = [T(n-3) + (2(n-2) + 5)/3] + (2n + 3)/3 + (2n + 5)/3\n    T(n) = T(n-3) + (2n - 4 + 5)/3 + (2n + 3)/3 + (2n + 5)/3\n    T(n) = T(n-3) + (2n + 1)/3 + (2n + 3)/3 + (2n + 5)/3\n\n4.  **Cuarta expansi√≥n:** Sustituimos T(n-3) = T(n-4) + (2(n-3) + 5)/3\n    T(n) = [T(n-4) + (2(n-3) + 5)/3] + (2n + 1)/3 + (2n + 3)/3 + (2n + 5)/3\n    T(n) = T(n-4) + (2n - 6 + 5)/3 + (2n + 1)/3 + (2n + 3)/3 + (2n + 5)/3\n    T(n) = T(n-4) + (2n - 1)/3 + (2n + 1)/3 + (2n + 3)/3 + (2n + 5)/3\n\n**Paso 2: Identificar el patr√≥n general**\nDespu√©s de `k` sustituciones, la recurrencia toma la forma:\nT(n) = T(n-k) + (1/3) * [ (2(n-k+1) + 5) + (2(n-k+2) + 5) + ... + (2n + 5) ]\nEsto se puede expresar como una sumatoria:\nT(n) = T(n-k) + (1/3) * Œ£[i=n-k+1 to n] (2i + 5)\n\n**Paso 3: Determinar cu√°ndo se alcanza el caso base**\nAsumiendo que el caso base es T(1), necesitamos que el argumento de T sea 1:\nn - k = 1\nPor lo tanto, k = n - 1.\n\n**Paso 4: Sustituir el caso base y simplificar**\nSustituimos k = n-1 en la expresi√≥n general:\nT(n) = T(n-(n-1)) + (1/3) * Œ£[i=n-(n-1)+1 to n] (2i + 5)\nT(n) = T(1) + (1/3) * Œ£[i=2 to n] (2i + 5)\n\nPara simplificar la sumatoria Œ£[i=2 to n] (2i + 5):\nŒ£[i=2 to n] (2i + 5) = Œ£[i=1 to n] (2i + 5) - (2(1) + 5)\n                      = Œ£[i=1 to n] (2i + 5) - 7\n\nAhora, evaluamos Œ£[i=1 to n] (2i + 5):\nŒ£[i=1 to n] (2i + 5) = Œ£[i=1 to n] 2i + Œ£[i=1 to n] 5\n                      = 2 * Œ£[i=1 to n] i + 5 * n\n                      = 2 * [n(n+1)/2] + 5n\n                      = n(n+1) + 5n\n                      = n¬≤ + n + 5n\n                      = n¬≤ + 6n\n\nSustituyendo esto de nuevo en la expresi√≥n para T(n):\nT(n) = T(1) + (1/3) * [ (n¬≤ + 6n) - 7 ]\n\nAsumiendo un caso base T(1) = 1 (si no se especifica lo contrario):\nT(n) = 1 + (n¬≤ + 6n - 7)/3\nT(n) = (3 + n¬≤ + 6n - 7)/3\nT(n) = (n¬≤ + 6n - 4)/3\n\n**Paso 5: Expresar forma cerrada y complejidad**\nLa forma cerrada de la soluci√≥n es T(n) = (n¬≤ + 6n - 4)/3.\nEl t√©rmino dominante es n¬≤, por lo tanto, la complejidad asint√≥tica es O(n¬≤).",
            "applicable": true,
            "method": "Sustituci√≥n Inteligente",
            "closed_form": "T(n) = (n¬≤ + 6n - 4)/3",
            "pattern": "T(n-k) + (1/3) * Œ£[i=n-k+1 to n] (2i + 5)",
            "details": {
              "recurrence_pattern": "T(n-k) + (1/3) * Œ£[i=n-k+1 to n] (2i + 5)",
              "pattern_identification": "T(n-k) + (1/3) * Œ£[i=n-k+1 to n] (2i + 5)",
              "base_case_substitution": "Para el caso base T(1), tenemos n - k = 1, lo que implica k = n - 1. Sustituyendo k en el patr√≥n general: T(n) = T(1) + (1/3) * Œ£[i=2 to n] (2i + 5)",
              "closed_form": "T(n) = (n¬≤ + 6n - 4)/3"
            }
          },
          "classification_confidence": 0.9,
          "classification_reasoning": "Recurrencia lineal con UN solo t√©rmino recursivo T(n-1). Trabajo adicional: =+(2n+5)/3. La sustituci√≥n inteligente permite expandir iterativamente la recurrencia para identificar el patr√≥n general."
        }
      ],
      "diagrams": {
        "tree_method_best": "graph TD\n    %% Estilos\n    classDef root fill:#f9f,stroke:#333,stroke-width:2px;\n    classDef leaf fill:#dfd,stroke:#333,stroke-width:1px;\n    classDef node fill:#fff,stroke:#333,stroke-width:1px;\n\n    subgraph cluster_0 [\"BEST: T(n)=2T(n/2)+n\"]\n    direction TB\n    T0_L0_P0(\"T(n)\"):::root\n    T0_L1_P0(\"T(n/2)\"):::node\n    T0_L1_P1(\"T(n/2)\"):::node\n    T0_L0_P0 --> T0_L1_P0\n    T0_L0_P0 --> T0_L1_P1\n    T0_L2_P0(\"T(n/4)\"):::node\n    T0_L2_P1(\"T(n/4)\"):::node\n    T0_L2_P2(\"T(n/4)\"):::node\n    T0_L2_P3(\"T(n/4)\"):::node\n    T0_L1_P0 --> T0_L2_P0\n    T0_L1_P0 --> T0_L2_P1\n    T0_L1_P1 --> T0_L2_P2\n    T0_L1_P1 --> T0_L2_P3\n    T0_L3_P0(\"T(n/8)\"):::leaf\n    T0_L3_P1(\"T(n/8)\"):::leaf\n    T0_L3_P2(\"T(n/8)\"):::leaf\n    T0_L3_P3(\"T(n/8)\"):::leaf\n    T0_L3_P4(\"T(n/8)\"):::leaf\n    T0_L3_P5(\"T(n/8)\"):::leaf\n    T0_L3_P6(\"T(n/8)\"):::leaf\n    T0_L3_P7(\"T(n/8)\"):::leaf\n    T0_L2_P0 --> T0_L3_P0\n    T0_L2_P0 --> T0_L3_P1\n    T0_L2_P1 --> T0_L3_P2\n    T0_L2_P1 --> T0_L3_P3\n    T0_L2_P2 --> T0_L3_P4\n    T0_L2_P2 --> T0_L3_P5\n    T0_L2_P3 --> T0_L3_P6\n    T0_L2_P3 --> T0_L3_P7\n    end",
        "tree_method_worst": "graph TD\n    %% Estilos\n    classDef root fill:#f9f,stroke:#333,stroke-width:2px;\n    classDef leaf fill:#dfd,stroke:#333,stroke-width:1px;\n    classDef node fill:#fff,stroke:#333,stroke-width:1px;\n\n    subgraph cluster_1 [\"WORST: T(n)=T(n-1)+n\"]\n    direction TB\n    T1_L0_P0(\"T(n)\"):::root\n    T1_L1_P0(\"T(n-1)\"):::node\n    T1_L0_P0 --> T1_L1_P0\n    T1_L2_P0(\"T(n-2)\"):::node\n    T1_L1_P0 --> T1_L2_P0\n    T1_L3_P0(\"T(n-3)\"):::leaf\n    T1_L2_P0 --> T1_L3_P0\n    end",
        "tree_method_average": "graph TD\n    %% Estilos\n    classDef root fill:#f9f,stroke:#333,stroke-width:2px;\n    classDef leaf fill:#dfd,stroke:#333,stroke-width:1px;\n    classDef node fill:#fff,stroke:#333,stroke-width:1px;\n\n    subgraph cluster_2 [\"AVERAGE: T(n) = T(n-1) + (2n + 5)/3\"]\n    direction TB\n    T2_L0_P0(\"T(n)\"):::root\n    T2_L1_P0(\"T(n-1)\"):::node\n    T2_L0_P0 --> T2_L1_P0\n    T2_L2_P0(\"T(n-2)\"):::node\n    T2_L1_P0 --> T2_L2_P0\n    T2_L3_P0(\"T(n-3)\"):::leaf\n    T2_L2_P0 --> T2_L3_P0\n    end"
      },
      "extra": {
        "has_multiple_cases": true,
        "analysis_details": [
          {
            "case_type": "best_case",
            "equation": "T(n)=2T(n/2)+n, T(1)=1",
            "original_equation": "T(n)=2T(n/2)+n, T(1)=1",
            "simplification": null,
            "method": "master_theorem",
            "method_enum": "master_theorem",
            "complexity": "n log n",
            "steps": [
              "**Paso 1 - Par√°metros:**",
              " a = 2, b = 2",
              " f(n) = n",
              "",
              "**Paso 2 - Exponente Cr√≠tico:**",
              " log_2(2) ‚âà n^1",
              "",
              "**Paso 3 - An√°lisis de L√≠mite (SymPy):**",
              " f(n) crece a la misma velocidad que n^E",
              "",
              "**Paso 4 - Conclusi√≥n:**",
              " Aplica **Caso 2**",
              " T√©rmino dominante: n log n"
            ],
            "explanation": "1.  **Identificaci√≥n de Par√°metros:**\n    *   Tenemos a = 2 (dos subproblemas).\n    *   Tenemos b = 2 (cada subproblema es de tama√±o n/2).\n    *   Tenemos f(n) = n (el trabajo adicional fuera de las llamadas recursivas).\n\n2.  **C√°lculo del Exponente Cr√≠tico (E):**\n    *   Calculamos E = log_b a = log_2 2.\n    *   Esto nos da E = 1.\n    *   Por lo tanto, el t√©rmino de comparaci√≥n es n^E = n^1 = n.\n\n3.  **C√°lculo e Interpretaci√≥n del L√≠mite:**\n    *   Ahora comparamos f(n) con n^E calculando el l√≠mite:\n        L = lim (n -> ‚àû) [f(n) / n^E]\n        L = lim (n -> ‚àû) [n / n^1]\n        L = lim (n -> ‚àû) [1]\n        L = 1\n    *   Dado que el l√≠mite es una constante positiva (1), esto significa que f(n) y n^E crecen a la misma velocidad asint√≥ticamente.\n\n4.  **Conclusi√≥n del Caso y Complejidad:**\n    *   Esta situaci√≥n corresponde al **Caso 2** del Teorema Maestro.\n    *   Cuando f(n) y n^E son asint√≥ticamente iguales, la complejidad se determina multiplicando n^E por un factor logar√≠tmico.\n    *   La complejidad final es **n log n**.",
            "details": {
              "complexity": "n log n",
              "steps": [
                "**Paso 1 - Par√°metros:**",
                " a = 2, b = 2",
                " f(n) = n",
                "",
                "**Paso 2 - Exponente Cr√≠tico:**",
                " log_2(2) ‚âà n^1",
                "",
                "**Paso 3 - An√°lisis de L√≠mite (SymPy):**",
                " f(n) crece a la misma velocidad que n^E",
                "",
                "**Paso 4 - Conclusi√≥n:**",
                " Aplica **Caso 2**",
                " T√©rmino dominante: n log n"
              ],
              "explanation": "1.  **Identificaci√≥n de Par√°metros:**\n    *   Tenemos a = 2 (dos subproblemas).\n    *   Tenemos b = 2 (cada subproblema es de tama√±o n/2).\n    *   Tenemos f(n) = n (el trabajo adicional fuera de las llamadas recursivas).\n\n2.  **C√°lculo del Exponente Cr√≠tico (E):**\n    *   Calculamos E = log_b a = log_2 2.\n    *   Esto nos da E = 1.\n    *   Por lo tanto, el t√©rmino de comparaci√≥n es n^E = n^1 = n.\n\n3.  **C√°lculo e Interpretaci√≥n del L√≠mite:**\n    *   Ahora comparamos f(n) con n^E calculando el l√≠mite:\n        L = lim (n -> ‚àû) [f(n) / n^E]\n        L = lim (n -> ‚àû) [n / n^1]\n        L = lim (n -> ‚àû) [1]\n        L = 1\n    *   Dado que el l√≠mite es una constante positiva (1), esto significa que f(n) y n^E crecen a la misma velocidad asint√≥ticamente.\n\n4.  **Conclusi√≥n del Caso y Complejidad:**\n    *   Esta situaci√≥n corresponde al **Caso 2** del Teorema Maestro.\n    *   Cuando f(n) y n^E son asint√≥ticamente iguales, la complejidad se determina multiplicando n^E por un factor logar√≠tmico.\n    *   La complejidad final es **n log n**.",
              "applicable": true,
              "method": "Teorema Maestro",
              "case": "Caso 2",
              "a": 2,
              "b": 2,
              "log_b_a": "n^1"
            },
            "classification_confidence": 0.95,
            "classification_reasoning": "Ecuaci√≥n en forma T(n) = aT(n/2) + f(n). Divide el problema en 1 subproblema(s) de tama√±o n/2. Trabajo adicional: =+n,=1. El Teorema Maestro es el m√©todo √≥ptimo."
          },
          {
            "case_type": "worst_case",
            "equation": "T(n)=T(n-1)+n, T(1)=1",
            "original_equation": "T(n)=T(n-1)+n, T(1)=1",
            "simplification": null,
            "method": "equation_characteristics",
            "method_enum": "equation_characteristics",
            "complexity": "n^2",
            "steps": [
              "**Soluci√≥n Exacta (SymPy):** n(n+1)/2",
              "**Crecimiento asint√≥tico:** n^2",
              "",
              "**Explicaci√≥n Te√≥rica:**",
              "Aunque la herramienta SymPy report√≥ un error en su c√°lculo simb√≥lico, el procedimiento est√°ndar para resolver la recurrencia lineal no homog√©nea T(n) = T(n-1) + n con la condici√≥n inicial T(1) = 1 es el siguiente, y la soluci√≥n exacta que se obtiene es T(n) = n(n+1)/2.\n\n**Paso 1: Identificar la forma de la recurrencia.**\nLa recurrencia T(n) = T(n-1) + n es una recurrencia lineal de primer orden no homog√©nea, ya que tiene un t√©rmino T(n-1) y un t√©rmino no constante 'n'.\n\n**Paso 2: Resolver la parte homog√©nea.**\nConsideramos la parte homog√©nea de la recurrencia: T(n) = T(n-1).\nPara encontrar la soluci√≥n homog√©nea T_h(n), formamos la ecuaci√≥n caracter√≠stica reemplazando T(n) por r^n y T(n-1) por r^(n-1):\nr^n = r^(n-1)\nDividiendo por r^(n-1) (asumiendo r ‚â† 0), obtenemos la ecuaci√≥n caracter√≠stica:\nr - 1 = 0\n\n**Paso 3: Encontrar las ra√≠ces de la ecuaci√≥n caracter√≠stica.**\nLa √∫nica ra√≠z de la ecuaci√≥n caracter√≠stica r - 1 = 0 es:\nr_1 = 1\n\n**Paso 4: Formar la soluci√≥n homog√©nea.**\nDado que tenemos una ra√≠z real y no repetida (r_1 = 1), la soluci√≥n homog√©nea es de la forma:\nT_h(n) = C * (r_1)^n = C * 1^n = C\nDonde C es una constante.\n\n**Paso 5: Encontrar la soluci√≥n particular.**\nEl t√©rmino no homog√©neo es f(n) = n. Como f(n) es un polinomio de grado 1, y la ra√≠z r=1 de la ecuaci√≥n caracter√≠stica tiene multiplicidad 1, la forma de la soluci√≥n particular T_p(n) debe ser un polinomio de grado 1 multiplicado por n (debido a la coincidencia con la ra√≠z). Es decir, T_p(n) = n * (An + B) = An^2 + Bn.\n\nSustituimos T_p(n) en la recurrencia original T(n) = T(n-1) + n:\nAn^2 + Bn = A(n-1)^2 + B(n-1) + n\nAn^2 + Bn = A(n^2 - 2n + 1) + Bn - B + n\nAn^2 + Bn = An^2 - 2An + A + Bn - B + n\n\nRestando An^2 + Bn de ambos lados:\n0 = -2An + A - B + n\n\nAgrupando t√©rminos por potencias de n:\n0 = (-2A + 1)n + (A - B)\n\nPara que esta ecuaci√≥n sea v√°lida para todo n, los coeficientes de cada potencia de n deben ser cero:\n1) Coeficiente de n: -2A + 1 = 0  =>  2A = 1  =>  A = 1/2\n2) T√©rmino constante: A - B = 0  =>  B = A  =>  B = 1/2\n\nPor lo tanto, la soluci√≥n particular es:\nT_p(n) = (1/2)n^2 + (1/2)n = n(n+1)/2\n\n**Paso 6: Formar la soluci√≥n general.**\nLa soluci√≥n general es la suma de la soluci√≥n homog√©nea y la soluci√≥n particular:\nT(n) = T_h(n) + T_p(n)\nT(n) = C + n(n+1)/2\n\n**Paso 7: Aplicar la condici√≥n inicial.**\nUsamos la condici√≥n inicial T(1) = 1 para encontrar el valor de la constante C:\nT(1) = C + 1(1+1)/2\n1 = C + 1(2)/2\n1 = C + 1\nC = 0\n\n**Paso 8: Escribir la soluci√≥n final exacta.**\nSustituyendo C = 0 en la soluci√≥n general, obtenemos la soluci√≥n exacta de la recurrencia:\nT(n) = n(n+1)/2\n\n**Paso 9: Determinar la complejidad (t√©rmino dominante).**\nEl t√©rmino dominante en la soluci√≥n T(n) = n(n+1)/2 = (n^2 + n)/2 es n^2.\n"
            ],
            "explanation": "Aunque la herramienta SymPy report√≥ un error en su c√°lculo simb√≥lico, el procedimiento est√°ndar para resolver la recurrencia lineal no homog√©nea T(n) = T(n-1) + n con la condici√≥n inicial T(1) = 1 es el siguiente, y la soluci√≥n exacta que se obtiene es T(n) = n(n+1)/2.\n\n**Paso 1: Identificar la forma de la recurrencia.**\nLa recurrencia T(n) = T(n-1) + n es una recurrencia lineal de primer orden no homog√©nea, ya que tiene un t√©rmino T(n-1) y un t√©rmino no constante 'n'.\n\n**Paso 2: Resolver la parte homog√©nea.**\nConsideramos la parte homog√©nea de la recurrencia: T(n) = T(n-1).\nPara encontrar la soluci√≥n homog√©nea T_h(n), formamos la ecuaci√≥n caracter√≠stica reemplazando T(n) por r^n y T(n-1) por r^(n-1):\nr^n = r^(n-1)\nDividiendo por r^(n-1) (asumiendo r ‚â† 0), obtenemos la ecuaci√≥n caracter√≠stica:\nr - 1 = 0\n\n**Paso 3: Encontrar las ra√≠ces de la ecuaci√≥n caracter√≠stica.**\nLa √∫nica ra√≠z de la ecuaci√≥n caracter√≠stica r - 1 = 0 es:\nr_1 = 1\n\n**Paso 4: Formar la soluci√≥n homog√©nea.**\nDado que tenemos una ra√≠z real y no repetida (r_1 = 1), la soluci√≥n homog√©nea es de la forma:\nT_h(n) = C * (r_1)^n = C * 1^n = C\nDonde C es una constante.\n\n**Paso 5: Encontrar la soluci√≥n particular.**\nEl t√©rmino no homog√©neo es f(n) = n. Como f(n) es un polinomio de grado 1, y la ra√≠z r=1 de la ecuaci√≥n caracter√≠stica tiene multiplicidad 1, la forma de la soluci√≥n particular T_p(n) debe ser un polinomio de grado 1 multiplicado por n (debido a la coincidencia con la ra√≠z). Es decir, T_p(n) = n * (An + B) = An^2 + Bn.\n\nSustituimos T_p(n) en la recurrencia original T(n) = T(n-1) + n:\nAn^2 + Bn = A(n-1)^2 + B(n-1) + n\nAn^2 + Bn = A(n^2 - 2n + 1) + Bn - B + n\nAn^2 + Bn = An^2 - 2An + A + Bn - B + n\n\nRestando An^2 + Bn de ambos lados:\n0 = -2An + A - B + n\n\nAgrupando t√©rminos por potencias de n:\n0 = (-2A + 1)n + (A - B)\n\nPara que esta ecuaci√≥n sea v√°lida para todo n, los coeficientes de cada potencia de n deben ser cero:\n1) Coeficiente de n: -2A + 1 = 0  =>  2A = 1  =>  A = 1/2\n2) T√©rmino constante: A - B = 0  =>  B = A  =>  B = 1/2\n\nPor lo tanto, la soluci√≥n particular es:\nT_p(n) = (1/2)n^2 + (1/2)n = n(n+1)/2\n\n**Paso 6: Formar la soluci√≥n general.**\nLa soluci√≥n general es la suma de la soluci√≥n homog√©nea y la soluci√≥n particular:\nT(n) = T_h(n) + T_p(n)\nT(n) = C + n(n+1)/2\n\n**Paso 7: Aplicar la condici√≥n inicial.**\nUsamos la condici√≥n inicial T(1) = 1 para encontrar el valor de la constante C:\nT(1) = C + 1(1+1)/2\n1 = C + 1(2)/2\n1 = C + 1\nC = 0\n\n**Paso 8: Escribir la soluci√≥n final exacta.**\nSustituyendo C = 0 en la soluci√≥n general, obtenemos la soluci√≥n exacta de la recurrencia:\nT(n) = n(n+1)/2\n\n**Paso 9: Determinar la complejidad (t√©rmino dominante).**\nEl t√©rmino dominante en la soluci√≥n T(n) = n(n+1)/2 = (n^2 + n)/2 es n^2.\n",
            "details": {
              "complexity": "n^2",
              "steps": [
                "**Soluci√≥n Exacta (SymPy):** n(n+1)/2",
                "**Crecimiento asint√≥tico:** n^2",
                "",
                "**Explicaci√≥n Te√≥rica:**",
                "Aunque la herramienta SymPy report√≥ un error en su c√°lculo simb√≥lico, el procedimiento est√°ndar para resolver la recurrencia lineal no homog√©nea T(n) = T(n-1) + n con la condici√≥n inicial T(1) = 1 es el siguiente, y la soluci√≥n exacta que se obtiene es T(n) = n(n+1)/2.\n\n**Paso 1: Identificar la forma de la recurrencia.**\nLa recurrencia T(n) = T(n-1) + n es una recurrencia lineal de primer orden no homog√©nea, ya que tiene un t√©rmino T(n-1) y un t√©rmino no constante 'n'.\n\n**Paso 2: Resolver la parte homog√©nea.**\nConsideramos la parte homog√©nea de la recurrencia: T(n) = T(n-1).\nPara encontrar la soluci√≥n homog√©nea T_h(n), formamos la ecuaci√≥n caracter√≠stica reemplazando T(n) por r^n y T(n-1) por r^(n-1):\nr^n = r^(n-1)\nDividiendo por r^(n-1) (asumiendo r ‚â† 0), obtenemos la ecuaci√≥n caracter√≠stica:\nr - 1 = 0\n\n**Paso 3: Encontrar las ra√≠ces de la ecuaci√≥n caracter√≠stica.**\nLa √∫nica ra√≠z de la ecuaci√≥n caracter√≠stica r - 1 = 0 es:\nr_1 = 1\n\n**Paso 4: Formar la soluci√≥n homog√©nea.**\nDado que tenemos una ra√≠z real y no repetida (r_1 = 1), la soluci√≥n homog√©nea es de la forma:\nT_h(n) = C * (r_1)^n = C * 1^n = C\nDonde C es una constante.\n\n**Paso 5: Encontrar la soluci√≥n particular.**\nEl t√©rmino no homog√©neo es f(n) = n. Como f(n) es un polinomio de grado 1, y la ra√≠z r=1 de la ecuaci√≥n caracter√≠stica tiene multiplicidad 1, la forma de la soluci√≥n particular T_p(n) debe ser un polinomio de grado 1 multiplicado por n (debido a la coincidencia con la ra√≠z). Es decir, T_p(n) = n * (An + B) = An^2 + Bn.\n\nSustituimos T_p(n) en la recurrencia original T(n) = T(n-1) + n:\nAn^2 + Bn = A(n-1)^2 + B(n-1) + n\nAn^2 + Bn = A(n^2 - 2n + 1) + Bn - B + n\nAn^2 + Bn = An^2 - 2An + A + Bn - B + n\n\nRestando An^2 + Bn de ambos lados:\n0 = -2An + A - B + n\n\nAgrupando t√©rminos por potencias de n:\n0 = (-2A + 1)n + (A - B)\n\nPara que esta ecuaci√≥n sea v√°lida para todo n, los coeficientes de cada potencia de n deben ser cero:\n1) Coeficiente de n: -2A + 1 = 0  =>  2A = 1  =>  A = 1/2\n2) T√©rmino constante: A - B = 0  =>  B = A  =>  B = 1/2\n\nPor lo tanto, la soluci√≥n particular es:\nT_p(n) = (1/2)n^2 + (1/2)n = n(n+1)/2\n\n**Paso 6: Formar la soluci√≥n general.**\nLa soluci√≥n general es la suma de la soluci√≥n homog√©nea y la soluci√≥n particular:\nT(n) = T_h(n) + T_p(n)\nT(n) = C + n(n+1)/2\n\n**Paso 7: Aplicar la condici√≥n inicial.**\nUsamos la condici√≥n inicial T(1) = 1 para encontrar el valor de la constante C:\nT(1) = C + 1(1+1)/2\n1 = C + 1(2)/2\n1 = C + 1\nC = 0\n\n**Paso 8: Escribir la soluci√≥n final exacta.**\nSustituyendo C = 0 en la soluci√≥n general, obtenemos la soluci√≥n exacta de la recurrencia:\nT(n) = n(n+1)/2\n\n**Paso 9: Determinar la complejidad (t√©rmino dominante).**\nEl t√©rmino dominante en la soluci√≥n T(n) = n(n+1)/2 = (n^2 + n)/2 es n^2.\n"
              ],
              "explanation": "Aunque la herramienta SymPy report√≥ un error en su c√°lculo simb√≥lico, el procedimiento est√°ndar para resolver la recurrencia lineal no homog√©nea T(n) = T(n-1) + n con la condici√≥n inicial T(1) = 1 es el siguiente, y la soluci√≥n exacta que se obtiene es T(n) = n(n+1)/2.\n\n**Paso 1: Identificar la forma de la recurrencia.**\nLa recurrencia T(n) = T(n-1) + n es una recurrencia lineal de primer orden no homog√©nea, ya que tiene un t√©rmino T(n-1) y un t√©rmino no constante 'n'.\n\n**Paso 2: Resolver la parte homog√©nea.**\nConsideramos la parte homog√©nea de la recurrencia: T(n) = T(n-1).\nPara encontrar la soluci√≥n homog√©nea T_h(n), formamos la ecuaci√≥n caracter√≠stica reemplazando T(n) por r^n y T(n-1) por r^(n-1):\nr^n = r^(n-1)\nDividiendo por r^(n-1) (asumiendo r ‚â† 0), obtenemos la ecuaci√≥n caracter√≠stica:\nr - 1 = 0\n\n**Paso 3: Encontrar las ra√≠ces de la ecuaci√≥n caracter√≠stica.**\nLa √∫nica ra√≠z de la ecuaci√≥n caracter√≠stica r - 1 = 0 es:\nr_1 = 1\n\n**Paso 4: Formar la soluci√≥n homog√©nea.**\nDado que tenemos una ra√≠z real y no repetida (r_1 = 1), la soluci√≥n homog√©nea es de la forma:\nT_h(n) = C * (r_1)^n = C * 1^n = C\nDonde C es una constante.\n\n**Paso 5: Encontrar la soluci√≥n particular.**\nEl t√©rmino no homog√©neo es f(n) = n. Como f(n) es un polinomio de grado 1, y la ra√≠z r=1 de la ecuaci√≥n caracter√≠stica tiene multiplicidad 1, la forma de la soluci√≥n particular T_p(n) debe ser un polinomio de grado 1 multiplicado por n (debido a la coincidencia con la ra√≠z). Es decir, T_p(n) = n * (An + B) = An^2 + Bn.\n\nSustituimos T_p(n) en la recurrencia original T(n) = T(n-1) + n:\nAn^2 + Bn = A(n-1)^2 + B(n-1) + n\nAn^2 + Bn = A(n^2 - 2n + 1) + Bn - B + n\nAn^2 + Bn = An^2 - 2An + A + Bn - B + n\n\nRestando An^2 + Bn de ambos lados:\n0 = -2An + A - B + n\n\nAgrupando t√©rminos por potencias de n:\n0 = (-2A + 1)n + (A - B)\n\nPara que esta ecuaci√≥n sea v√°lida para todo n, los coeficientes de cada potencia de n deben ser cero:\n1) Coeficiente de n: -2A + 1 = 0  =>  2A = 1  =>  A = 1/2\n2) T√©rmino constante: A - B = 0  =>  B = A  =>  B = 1/2\n\nPor lo tanto, la soluci√≥n particular es:\nT_p(n) = (1/2)n^2 + (1/2)n = n(n+1)/2\n\n**Paso 6: Formar la soluci√≥n general.**\nLa soluci√≥n general es la suma de la soluci√≥n homog√©nea y la soluci√≥n particular:\nT(n) = T_h(n) + T_p(n)\nT(n) = C + n(n+1)/2\n\n**Paso 7: Aplicar la condici√≥n inicial.**\nUsamos la condici√≥n inicial T(1) = 1 para encontrar el valor de la constante C:\nT(1) = C + 1(1+1)/2\n1 = C + 1(2)/2\n1 = C + 1\nC = 0\n\n**Paso 8: Escribir la soluci√≥n final exacta.**\nSustituyendo C = 0 en la soluci√≥n general, obtenemos la soluci√≥n exacta de la recurrencia:\nT(n) = n(n+1)/2\n\n**Paso 9: Determinar la complejidad (t√©rmino dominante).**\nEl t√©rmino dominante en la soluci√≥n T(n) = n(n+1)/2 = (n^2 + n)/2 es n^2.\n",
              "applicable": true,
              "method": "Ecuaci√≥n Caracter√≠stica",
              "final_solution": "n(n+1)/2"
            },
            "classification_confidence": 0.9,
            "classification_reasoning": "Recurrencia lineal de orden superior. T√©rminos: T(n-1). Trabajo adicional: =+n,=1. La ecuaci√≥n caracter√≠stica es ideal para resolver este tipo de recurrencia.."
          },
          {
            "case_type": "average_case",
            "equation": "T(n) = T(n-1) + (2n + 5)/3",
            "original_equation": "T(n)=(2/n)√óŒ£[i=1 to n]T(i)+n, donde T(i)=T(i-1)+i, T(1)=1",
            "simplification": {
              "original": "T(n)=(2/n)√óŒ£[i=1 to n]T(i)+n, donde T(i)=T(i-1)+i, T(1)=1",
              "simplified": "T(n) = T(n-1) + (2n + 5)/3",
              "steps": [
                "Paso 1: Resolvemos T_int(i). La recurrencia T(i) = T(i-1) + i con T(1)=1 se resuelve como la suma de los primeros i n√∫meros naturales, T_int(i) = i(i+1)/2.",
                "Paso 2: Evaluamos la sumatoria S(n) = Œ£[i=1 to n] T_int(i). Sustituimos T_int(i): S(n) = Œ£[i=1 to n] i(i+1)/2 = (1/2) * Œ£[i=1 to n] (i^2 + i). Usando las f√≥rmulas de sumatoria: S(n) = (1/2) * [n(n+1)(2n+1)/6 + n(n+1)/2] = (1/2) * n(n+1) * [(2n+1)/6 + 3/6] = (1/2) * n(n+1) * (2n+4)/6 = (1/2) * n(n+1) * (n+2)/3 = n(n+1)(n+2)/6.",
                "Paso 3: Obtenemos la forma expl√≠cita de T(n). Sustituimos S(n) en la ecuaci√≥n original: T(n) = (2/n) * [n(n+1)(n+2)/6] + n = (n+1)(n+2)/3 + n = (n^2 + 3n + 2)/3 + 3n/3 = (n^2 + 6n + 2)/3.",
                "Paso 4: Derivamos la recurrencia final g'(n) = T(n) - T(n-1). T(n-1) = ((n-1)^2 + 6(n-1) + 2)/3 = (n^2 - 2n + 1 + 6n - 6 + 2)/3 = (n^2 + 4n - 3)/3. Restamos: g'(n) = (n^2 + 6n + 2)/3 - (n^2 + 4n - 3)/3 = (n^2 + 6n + 2 - n^2 - 4n + 3)/3 = (2n + 5)/3."
              ],
              "explicit_form": "T(n) = (n^2 + 6n + 2)/3",
              "summation_resolved": "n(n+1)(n+2)/6",
              "confidence": 1.0,
              "pattern_type": "quadratic"
            },
            "method": "intelligent_substitution",
            "method_enum": "intelligent_substitution",
            "complexity": "O(n¬≤)",
            "steps": [
              "**Paso 1 - Expandir la recurrencia iterativamente:**",
              "   T(n) = T(n-1) + (2n + 5)/3",
              "   T(n) = T(n-2) + (2n + 3)/3 + (2n + 5)/3",
              "   T(n) = T(n-3) + (2n + 1)/3 + (2n + 3)/3 + (2n + 5)/3",
              "   T(n) = T(n-4) + (2n - 1)/3 + (2n + 1)/3 + (2n + 3)/3 + (2n + 5)/3",
              "",
              "**Paso 2 - Identificar el patr√≥n general:**",
              "   Despu√©s de k sustituciones:",
              "   T(n-k) + (1/3) * Œ£[i=n-k+1 to n] (2i + 5)",
              "",
              "**Paso 3 - Sustituir el caso base:**",
              "   Para el caso base T(1), tenemos n - k = 1, lo que implica k = n - 1. Sustituyendo k en el patr√≥n general: T(n) = T(1) + (1/3) * Œ£[i=2 to n] (2i + 5)",
              "",
              "**Paso 4 - Forma cerrada:**",
              "   T(n) = (n¬≤ + 6n - 4)/3",
              "",
              "**Paso 5 - Complejidad final:**",
              "   O(n¬≤)"
            ],
            "explanation": "**Paso 1: Expandir la recurrencia iterativamente**\nLa ecuaci√≥n de recurrencia dada es T(n) = T(n-1) + (2n + 5)/3.\n\n1.  **Primera expansi√≥n:**\n    T(n) = T(n-1) + (2n + 5)/3\n\n2.  **Segunda expansi√≥n:** Sustituimos T(n-1) = T(n-2) + (2(n-1) + 5)/3\n    T(n) = [T(n-2) + (2(n-1) + 5)/3] + (2n + 5)/3\n    T(n) = T(n-2) + (2n - 2 + 5)/3 + (2n + 5)/3\n    T(n) = T(n-2) + (2n + 3)/3 + (2n + 5)/3\n\n3.  **Tercera expansi√≥n:** Sustituimos T(n-2) = T(n-3) + (2(n-2) + 5)/3\n    T(n) = [T(n-3) + (2(n-2) + 5)/3] + (2n + 3)/3 + (2n + 5)/3\n    T(n) = T(n-3) + (2n - 4 + 5)/3 + (2n + 3)/3 + (2n + 5)/3\n    T(n) = T(n-3) + (2n + 1)/3 + (2n + 3)/3 + (2n + 5)/3\n\n4.  **Cuarta expansi√≥n:** Sustituimos T(n-3) = T(n-4) + (2(n-3) + 5)/3\n    T(n) = [T(n-4) + (2(n-3) + 5)/3] + (2n + 1)/3 + (2n + 3)/3 + (2n + 5)/3\n    T(n) = T(n-4) + (2n - 6 + 5)/3 + (2n + 1)/3 + (2n + 3)/3 + (2n + 5)/3\n    T(n) = T(n-4) + (2n - 1)/3 + (2n + 1)/3 + (2n + 3)/3 + (2n + 5)/3\n\n**Paso 2: Identificar el patr√≥n general**\nDespu√©s de `k` sustituciones, la recurrencia toma la forma:\nT(n) = T(n-k) + (1/3) * [ (2(n-k+1) + 5) + (2(n-k+2) + 5) + ... + (2n + 5) ]\nEsto se puede expresar como una sumatoria:\nT(n) = T(n-k) + (1/3) * Œ£[i=n-k+1 to n] (2i + 5)\n\n**Paso 3: Determinar cu√°ndo se alcanza el caso base**\nAsumiendo que el caso base es T(1), necesitamos que el argumento de T sea 1:\nn - k = 1\nPor lo tanto, k = n - 1.\n\n**Paso 4: Sustituir el caso base y simplificar**\nSustituimos k = n-1 en la expresi√≥n general:\nT(n) = T(n-(n-1)) + (1/3) * Œ£[i=n-(n-1)+1 to n] (2i + 5)\nT(n) = T(1) + (1/3) * Œ£[i=2 to n] (2i + 5)\n\nPara simplificar la sumatoria Œ£[i=2 to n] (2i + 5):\nŒ£[i=2 to n] (2i + 5) = Œ£[i=1 to n] (2i + 5) - (2(1) + 5)\n                      = Œ£[i=1 to n] (2i + 5) - 7\n\nAhora, evaluamos Œ£[i=1 to n] (2i + 5):\nŒ£[i=1 to n] (2i + 5) = Œ£[i=1 to n] 2i + Œ£[i=1 to n] 5\n                      = 2 * Œ£[i=1 to n] i + 5 * n\n                      = 2 * [n(n+1)/2] + 5n\n                      = n(n+1) + 5n\n                      = n¬≤ + n + 5n\n                      = n¬≤ + 6n\n\nSustituyendo esto de nuevo en la expresi√≥n para T(n):\nT(n) = T(1) + (1/3) * [ (n¬≤ + 6n) - 7 ]\n\nAsumiendo un caso base T(1) = 1 (si no se especifica lo contrario):\nT(n) = 1 + (n¬≤ + 6n - 7)/3\nT(n) = (3 + n¬≤ + 6n - 7)/3\nT(n) = (n¬≤ + 6n - 4)/3\n\n**Paso 5: Expresar forma cerrada y complejidad**\nLa forma cerrada de la soluci√≥n es T(n) = (n¬≤ + 6n - 4)/3.\nEl t√©rmino dominante es n¬≤, por lo tanto, la complejidad asint√≥tica es O(n¬≤).",
            "details": {
              "complexity": "O(n¬≤)",
              "steps": [
                "**Paso 1 - Expandir la recurrencia iterativamente:**",
                "   T(n) = T(n-1) + (2n + 5)/3",
                "   T(n) = T(n-2) + (2n + 3)/3 + (2n + 5)/3",
                "   T(n) = T(n-3) + (2n + 1)/3 + (2n + 3)/3 + (2n + 5)/3",
                "   T(n) = T(n-4) + (2n - 1)/3 + (2n + 1)/3 + (2n + 3)/3 + (2n + 5)/3",
                "",
                "**Paso 2 - Identificar el patr√≥n general:**",
                "   Despu√©s de k sustituciones:",
                "   T(n-k) + (1/3) * Œ£[i=n-k+1 to n] (2i + 5)",
                "",
                "**Paso 3 - Sustituir el caso base:**",
                "   Para el caso base T(1), tenemos n - k = 1, lo que implica k = n - 1. Sustituyendo k en el patr√≥n general: T(n) = T(1) + (1/3) * Œ£[i=2 to n] (2i + 5)",
                "",
                "**Paso 4 - Forma cerrada:**",
                "   T(n) = (n¬≤ + 6n - 4)/3",
                "",
                "**Paso 5 - Complejidad final:**",
                "   O(n¬≤)"
              ],
              "explanation": "**Paso 1: Expandir la recurrencia iterativamente**\nLa ecuaci√≥n de recurrencia dada es T(n) = T(n-1) + (2n + 5)/3.\n\n1.  **Primera expansi√≥n:**\n    T(n) = T(n-1) + (2n + 5)/3\n\n2.  **Segunda expansi√≥n:** Sustituimos T(n-1) = T(n-2) + (2(n-1) + 5)/3\n    T(n) = [T(n-2) + (2(n-1) + 5)/3] + (2n + 5)/3\n    T(n) = T(n-2) + (2n - 2 + 5)/3 + (2n + 5)/3\n    T(n) = T(n-2) + (2n + 3)/3 + (2n + 5)/3\n\n3.  **Tercera expansi√≥n:** Sustituimos T(n-2) = T(n-3) + (2(n-2) + 5)/3\n    T(n) = [T(n-3) + (2(n-2) + 5)/3] + (2n + 3)/3 + (2n + 5)/3\n    T(n) = T(n-3) + (2n - 4 + 5)/3 + (2n + 3)/3 + (2n + 5)/3\n    T(n) = T(n-3) + (2n + 1)/3 + (2n + 3)/3 + (2n + 5)/3\n\n4.  **Cuarta expansi√≥n:** Sustituimos T(n-3) = T(n-4) + (2(n-3) + 5)/3\n    T(n) = [T(n-4) + (2(n-3) + 5)/3] + (2n + 1)/3 + (2n + 3)/3 + (2n + 5)/3\n    T(n) = T(n-4) + (2n - 6 + 5)/3 + (2n + 1)/3 + (2n + 3)/3 + (2n + 5)/3\n    T(n) = T(n-4) + (2n - 1)/3 + (2n + 1)/3 + (2n + 3)/3 + (2n + 5)/3\n\n**Paso 2: Identificar el patr√≥n general**\nDespu√©s de `k` sustituciones, la recurrencia toma la forma:\nT(n) = T(n-k) + (1/3) * [ (2(n-k+1) + 5) + (2(n-k+2) + 5) + ... + (2n + 5) ]\nEsto se puede expresar como una sumatoria:\nT(n) = T(n-k) + (1/3) * Œ£[i=n-k+1 to n] (2i + 5)\n\n**Paso 3: Determinar cu√°ndo se alcanza el caso base**\nAsumiendo que el caso base es T(1), necesitamos que el argumento de T sea 1:\nn - k = 1\nPor lo tanto, k = n - 1.\n\n**Paso 4: Sustituir el caso base y simplificar**\nSustituimos k = n-1 en la expresi√≥n general:\nT(n) = T(n-(n-1)) + (1/3) * Œ£[i=n-(n-1)+1 to n] (2i + 5)\nT(n) = T(1) + (1/3) * Œ£[i=2 to n] (2i + 5)\n\nPara simplificar la sumatoria Œ£[i=2 to n] (2i + 5):\nŒ£[i=2 to n] (2i + 5) = Œ£[i=1 to n] (2i + 5) - (2(1) + 5)\n                      = Œ£[i=1 to n] (2i + 5) - 7\n\nAhora, evaluamos Œ£[i=1 to n] (2i + 5):\nŒ£[i=1 to n] (2i + 5) = Œ£[i=1 to n] 2i + Œ£[i=1 to n] 5\n                      = 2 * Œ£[i=1 to n] i + 5 * n\n                      = 2 * [n(n+1)/2] + 5n\n                      = n(n+1) + 5n\n                      = n¬≤ + n + 5n\n                      = n¬≤ + 6n\n\nSustituyendo esto de nuevo en la expresi√≥n para T(n):\nT(n) = T(1) + (1/3) * [ (n¬≤ + 6n) - 7 ]\n\nAsumiendo un caso base T(1) = 1 (si no se especifica lo contrario):\nT(n) = 1 + (n¬≤ + 6n - 7)/3\nT(n) = (3 + n¬≤ + 6n - 7)/3\nT(n) = (n¬≤ + 6n - 4)/3\n\n**Paso 5: Expresar forma cerrada y complejidad**\nLa forma cerrada de la soluci√≥n es T(n) = (n¬≤ + 6n - 4)/3.\nEl t√©rmino dominante es n¬≤, por lo tanto, la complejidad asint√≥tica es O(n¬≤).",
              "applicable": true,
              "method": "Sustituci√≥n Inteligente",
              "closed_form": "T(n) = (n¬≤ + 6n - 4)/3",
              "pattern": "T(n-k) + (1/3) * Œ£[i=n-k+1 to n] (2i + 5)",
              "details": {
                "recurrence_pattern": "T(n-k) + (1/3) * Œ£[i=n-k+1 to n] (2i + 5)",
                "pattern_identification": "T(n-k) + (1/3) * Œ£[i=n-k+1 to n] (2i + 5)",
                "base_case_substitution": "Para el caso base T(1), tenemos n - k = 1, lo que implica k = n - 1. Sustituyendo k en el patr√≥n general: T(n) = T(1) + (1/3) * Œ£[i=2 to n] (2i + 5)",
                "closed_form": "T(n) = (n¬≤ + 6n - 4)/3"
              }
            },
            "classification_confidence": 0.9,
            "classification_reasoning": "Recurrencia lineal con UN solo t√©rmino recursivo T(n-1). Trabajo adicional: =+(2n+5)/3. La sustituci√≥n inteligente permite expandir iterativamente la recurrencia para identificar el patr√≥n general."
          }
        ],
        "was_replicated": false
      }
    },
    "complete": {
      "type": "recursive",
      "code_explain": "Quicksort es un algoritmo de ordenamiento altamente eficiente. Funciona seleccionando un elemento 'pivote' y partiendo el array en dos sub-arrays: uno con elementos menores que el pivote y otro con elementos mayores. Luego, ordena recursivamente los sub-arrays.",
      "complexity_line_to_line": [
        {
          "line": 1,
          "code": "quicksort(arr, low, high)",
          "complexity": "T(n)",
          "explanation": "Define la funci√≥n con un tama√±o de problema n = high - low + 1."
        },
        {
          "line": 2,
          "code": "begin",
          "complexity": "c1 * 0",
          "explanation": "Inicio de bloque, sin costo computacional."
        },
        {
          "line": 3,
          "code": "if (low < high) then",
          "complexity": "c2 * 1",
          "explanation": "Comparaci√≥n para el caso base. Costo constante."
        },
        {
          "line": 4,
          "code": "begin",
          "complexity": "c3 * 0",
          "explanation": "Inicio de bloque, sin costo computacional."
        },
        {
          "line": 5,
          "code": "pi ü°® CALL partition(arr, low, high)",
          "complexity": "c4 * n",
          "explanation": "La funci√≥n de partici√≥n recorre el sub-array de tama√±o n para colocar el pivote. Su costo es lineal, Œò(n)."
        },
        {
          "line": 6,
          "code": "CALL quicksort(arr, low, pi - 1)",
          "complexity": "T(k)",
          "explanation": "Primera llamada recursiva. El tama√±o del subproblema 'k' depende de la posici√≥n del pivote 'pi'."
        },
        {
          "line": 7,
          "code": "CALL quicksort(arr, pi + 1, high)",
          "complexity": "T(n-k-1)",
          "explanation": "Segunda llamada recursiva. El tama√±o es el resto del array, 'n-k-1'."
        },
        {
          "line": 8,
          "code": "end",
          "complexity": "c5 * 0",
          "explanation": "Fin de bloque, sin costo computacional."
        },
        {
          "line": 9,
          "code": "end",
          "complexity": "c6 * 0",
          "explanation": "Fin de bloque, sin costo computacional."
        }
      ],
      "explain_complexity": "**Algoritmo**: Quicksort\n**Categor√≠a**: Divide y Conquista\n**Tipo**: Recursivo\n\n**Ecuaci√≥n**: Caso Peor: T(n) = T(n-1) + T(0) + Œò(n) = T(n-1) + Œò(n), con T(1) = c. Caso Promedio/Mejor: T(n) = 2T(n/2) + Œò(n), con T(1) = c.\n**M√©todo de resoluci√≥n**: Para el caso peor se utiliza el M√©todo de Sustituci√≥n (expansi√≥n de la recurrencia). Para el caso promedio y mejor, se aplica el Teorema Maestro.\n**Complejidad final**: O(n log n) en el caso promedio, O(n¬≤) en el peor caso.\n\n**Notaciones asint√≥ticas**:\n- Mejor caso (Œ©): Œ©(n log n)\n- Peor caso (O): O(n¬≤)\n- Caso promedio (Œò): Œò(n log n)",
      "asymptotic_notation": {
        "best": "Œ©(n log n)",
        "worst": "O(n¬≤)",
        "average": "Œò(n log n)",
        "explanation": "Œ© (Omega) representa la cota inferior del tiempo de ejecuci√≥n, el mejor escenario posible. O (Big-O) representa la cota superior, el peor escenario posible. Œò (Theta) representa la cota ajustada, que ocurre cuando el mejor y el peor caso coinciden en orden de magnitud (caso promedio)."
      },
      "algorithm_name": "Quicksort",
      "algorithm_category": "Divide y Conquista",
      "equation": "Caso Peor: T(n) = T(n-1) + T(0) + Œò(n) = T(n-1) + Œò(n), con T(1) = c. Caso Promedio/Mejor: T(n) = 2T(n/2) + Œò(n), con T(1) = c.",
      "method_solution": "Para el caso peor se utiliza el M√©todo de Sustituci√≥n (expansi√≥n de la recurrencia). Para el caso promedio y mejor, se aplica el Teorema Maestro.",
      "solution_equation": "O(n log n) en el caso promedio, O(n¬≤) en el peor caso.",
      "explain_solution_steps": [
        "An√°lisis del Peor Caso (Partici√≥n desbalanceada): Ocurre cuando el pivote es siempre el elemento m√°s peque√±o o m√°s grande.",
        "1. Ecuaci√≥n de Recurrencia: T(n) = T(n-1) + T(0) + cn = T(n-1) + cn (ya que T(0) es constante).",
        "2. Expansi√≥n: T(n) = (T(n-2) + c(n-1)) + cn = T(n-2) + c(n-1) + cn.",
        "3. Expansi√≥n completa: T(n) = T(1) + c*2 + c*3 + ... + c*n = T(1) + c * Œ£(i=2 a n) i.",
        "4. Resoluci√≥n de la Sumatoria: La suma de los primeros n enteros es n(n+1)/2. La sumatoria es c * (n(n+1)/2 - 1).",
        "5. Resultado: La complejidad es dominada por el t√©rmino cuadr√°tico, por lo tanto, T(n) = O(n¬≤).",
        "An√°lisis del Mejor/Caso Promedio (Partici√≥n balanceada): Ocurre cuando el pivote divide el array en dos mitades aproximadamente iguales.",
        "1. Ecuaci√≥n de Recurrencia: T(n) = 2T(n/2) + cn.",
        "2. Aplicaci√≥n del Teorema Maestro: T(n) = aT(n/b) + f(n).",
        "3. Identificaci√≥n de par√°metros: a = 2, b = 2, f(n) = cn.",
        "4. C√°lculo del exponente cr√≠tico: log_b(a) = log_2(2) = 1.",
        "5. Comparaci√≥n: Comparamos f(n) = cn con n^(log_b(a)) = n^1. Vemos que f(n) = Œò(n^1).",
        "6. Conclusi√≥n del Teorema (Caso 2): Como f(n) tiene el mismo orden de magnitud que n^(log_b(a)), la soluci√≥n es T(n) = Œò(n^(log_b(a)) * log n).",
        "7. Resultado: T(n) = Œò(n * log n)."
      ],
      "diagrams": null,
      "extra": {
        "pseudocode": "quicksort(arr, low, high)\nbegin\n    if (low < high) then\n    begin\n        pi ü°® CALL partition(arr, low, high)\n        CALL quicksort(arr, low, pi - 1)\n        CALL quicksort(arr, pi + 1, high)\n    end\nend",
        "analysis_complete": true
      }
    }
  }
}