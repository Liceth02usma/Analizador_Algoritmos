{
  "input_metadata": {
    "source_type": "rag_retrieval (ChromaDB)",
    "final_pseudocode": "bubble_sort(A, n)\nbegin\n    swapped ðŸ¡¨ T\n    i ðŸ¡¨ 0\n    while (swapped = T) do\n    begin\n        swapped ðŸ¡¨ F\n        for j ðŸ¡¨ 0 to n - 2 - i do\n        begin\n            if (A[j] > A[j+1]) then\n            begin\n                temp ðŸ¡¨ A[j]\n                A[j] ðŸ¡¨ A[j+1]\n                A[j+1] ðŸ¡¨ temp\n                swapped ðŸ¡¨ T\n            end\n        end\n        i ðŸ¡¨ i + 1\n    end\n    return A\nend"
  },
  "classification": {
    "type": "iterativo",
    "name": "Bubble Sort"
  },
  "analysis": {
    "type": "iterativo",
    "code_explain": "Bubble Sort es un algoritmo de ordenamiento simple que repetidamente recorre la lista, compara elementos adyacentes y los intercambia si estÃ¡n en el orden incorrecto. La pasada a travÃ©s de la lista se repite hasta que no se necesiten mÃ¡s intercambios, lo que indica que la lista estÃ¡ ordenada. Su eficiencia varÃ­a significativamente entre el mejor y el peor caso.",
    "complexity_line_to_line": "=== MEJOR CASO ===\n// Error al analizar.\\n\n    busqueda_lineal_rec(A, x, i, n)\n    begin\n        if (i = n) then\n            begin\n                return -1\n            end\n        else\n            begin\n                if (A[i] = x) then\n                    begin\n                        return i\n                    end\n                else\n                    begin\n                        return CALL busqueda_lineal_rec(A, x, i + 1, n)\n                    end\n            end\n    end\n\n    index ðŸ¡¨ CALL busqueda_lineal_rec(A, x, 0, n)\n    return index\n    \n\n=== PEOR CASO ===\n// Error al analizar.\\n\n    busqueda_lineal_rec(A, x, i, n)\n    begin\n        if (i = n) then\n            begin\n                return -1\n            end\n        else\n            begin\n                if (A[i] = x) then\n                    begin\n                        return i\n                    end\n                else\n                    begin\n                        return CALL busqueda_lineal_rec(A, x, i + 1, n)\n                    end\n            end\n    end\n\n    index ðŸ¡¨ CALL busqueda_lineal_rec(A, x, 0, n)\n    return index\n    \n\n=== CASO PROMEDIO ===\n// Error al analizar.\\n\n    busqueda_lineal_rec(A, x, i, n)\n    begin\n        if (i = n) then\n            begin\n                return -1\n            end\n        else\n            begin\n                if (A[i] = x) then\n                    begin\n                        return i\n                    end\n                else\n                    begin\n                        return CALL busqueda_lineal_rec(A, x, i + 1, n)\n                    end\n            end\n    end\n\n    index ðŸ¡¨ CALL busqueda_lineal_rec(A, x, 0, n)\n    return index\n    ",
    "explain_complexity": "Para el algoritmo Bubble Sort, el mejor caso resulta en una funciÃ³n de eficiencia lineal T(n) = An + B, mientras que el peor caso resulta en una funciÃ³n de eficiencia cuadrÃ¡tica T(n) = An^2 + Bn + C. Esto indica que el rendimiento del Bubble Sort es significativamente peor en el peor de los casos en comparaciÃ³n con el mejor caso.",
    "asymptotic_notation": {
      "best": "Î©(n)",
      "worst": "O(n^2)",
      "explanation": "El algoritmo Bubble Sort tiene una complejidad de tiempo de Î©(n) en el mejor caso y O(n^2) en el peor caso."
    },
    "algorithm_name": "Bubble Sort",
    "algorithm_category": "Iterativo / Bucle",
    "equation": [
      "Mejor: c1 + c2 + 2*c3 + c4 + n*c5 + (n-1)*c6 + c11 + c12",
      "Peor: c1 + c2 + (n+1)*c3 + n*c4 + (n*(n+1)/2)*c5 + (n*(n-1)/2)*c6 + (n*(n-1)/2)*(c7+c8+c9+c10) + n*c11 + c12"
    ],
    "method_solution": "MÃ©todo de Conteo de Pasos + Sumatorias",
    "solution_equation": [
      "Mejor: T(n) = (c5 + c6)n + (c1 + c2 + 2*c3 + c4 - c6 + c11 + c12)",
      "Peor: T(n) = (0.5*c5 + 0.5*c6 + 0.5*c7 + 0.5*c8 + 0.5*c9 + 0.5*c10)n^2 + (c3 + c4 + 0.5*c5 - 0.5*c6 - 0.5*c7 - 0.5*c8 - 0.5*c9 - 0.5*c10 + c11)n + (c1 + c2 + c3 + c12)"
    ],
    "explain_solution_steps": [
      "**Mejor**: c1 + c2 + 2*c3 + c4 + n*c5 + n*c6 - c6 + c11 + c12",
      "**Peor**: c1 + c2 + n*c3 + c3 + n*c4 + 0.5*n*n*c5 + 0.5*n*c5 + 0.5*n*n*c6 - 0.5*n*c6 + 0.5*n*n*(c7+c8+c9+c10) - 0.5*n*(c7+c8+c9+c10) + n*c11 + c12"
    ],
    "diagrams": {
      "main_flowchart": "graph TD\n    Start((Inicio)) --> InitVars[swapped = T, i = 0]\n    InitVars --> WhileCond{swapped = T?}\n    WhileCond -- SÃ­ --> ResetSwapped[swapped = F]\n    ResetSwapped --> ForLoopInit[j = 0]\n    ForLoopInit --> ForLoopCond{j < n - 1 - i?}\n    ForLoopCond -- SÃ­ --> IfCond{A[j] > A[j+1]?}\n    IfCond -- SÃ­ (Peor Caso) --> Swap[temp = A[j], A[j] = A[j+1], A[j+1] = temp]\n    Swap --> SetSwappedT[swapped = T]\n    SetSwappedT --> IncJ[j = j + 1]\n    IfCond -- No --> IncJ\n    IncJ --> ForLoopCond\n    ForLoopCond -- No --> IncI[i = i + 1]\n    IncI --> WhileCond\n    WhileCond -- No --> ReturnA[Return A]\n    ReturnA --> End((Fin))\n\n    Note right of WhileCond: El bucle 'while' se repite n veces.\n    Note right of ForLoopCond: El bucle 'for' se repite (n-1-i) veces en cada pasada.\n    Note right of IfCond: La condiciÃ³n A[j] > A[j+1] es casi siempre verdadera, forzando muchos intercambios."
    },
    "extra": {
      "is_case_dependent": true,
      "cases": [
        {
          "case_name": "Mejor",
          "condition": "El arreglo ya estÃ¡ ordenado.",
          "line_analysis": "=== MEJOR CASO ===\n// Error al analizar.\\n\n    busqueda_lineal_rec(A, x, i, n)\n    begin\n        if (i = n) then\n            begin\n                return -1\n            end\n        else\n            begin\n                if (A[i] = x) then\n                    begin\n                        return i\n                    end\n                else\n                    begin\n                        return CALL busqueda_lineal_rec(A, x, i + 1, n)\n                    end\n            end\n    end\n\n    index ðŸ¡¨ CALL busqueda_lineal_rec(A, x, 0, n)\n    return index\n",
          "raw_summation_str": "c1 + c2 + 2*c3 + c4 + n*c5 + (n-1)*c6 + c11 + c12",
          "math_steps": "c1 + c2 + 2*c3 + c4 + n*c5 + n*c6 - c6 + c11 + c12",
          "simplified_complexity": "(c5 + c6)n + (c1 + c2 + 2*c3 + c4 - c6 + c11 + c12)",
          "complexity_class": "n",
          "notation_type": "Î©",
          "big_o": "Î©(n)",
          "trace_diagram": "graph TD\n    Start((Inicio)) --> InitVars[swapped = T, i = 0]\n    InitVars --> WhileCond{swapped = T?}\n    WhileCond -- SÃ­ --> ResetSwapped[swapped = F]\n    ResetSwapped --> ForLoopInit[j = 0]\n    ForLoopInit --> ForLoopCond{j < n - 1 - i?}\n    ForLoopCond -- SÃ­ --> IfCond{A[j] > A[j+1]?}\n    IfCond -- No (Mejor Caso) --> IncJ[j = j + 1]\n    IncJ --> ForLoopCond\n    ForLoopCond -- No --> IncI[i = i + 1]\n    IncI --> WhileCond\n    WhileCond -- No --> ReturnA[Return A]\n    ReturnA --> End((Fin))\n\n    Note right of ForLoopCond: El bucle for se ejecuta n-1 veces en la primera pasada.\n    Note right of IfCond: La condiciÃ³n A[j] > A[j+1] siempre es falsa.\n    Note right of WhileCond: 'swapped' permanece F, el bucle 'while' termina despuÃ©s de la primera iteraciÃ³n."
        },
        {
          "case_name": "Peor",
          "condition": "El arreglo estÃ¡ ordenado en orden inverso.",
          "line_analysis": "=== PEOR CASO ===\n// Error al analizar.\\n\n    busqueda_lineal_rec(A, x, i, n)\n    begin\n        if (i = n) then\n            begin\n                return -1\n            end\n        else\n            begin\n                if (A[i] = x) then\n                    begin\n                        return i\n                    end\n                else\n                    begin\n                        return CALL busqueda_lineal_rec(A, x, i + 1, n)\n                    end\n            end\n    end\n\n    index ðŸ¡¨ CALL busqueda_lineal_rec(A, x, 0, n)\n    return index\n",
          "raw_summation_str": "c1 + c2 + (n+1)*c3 + n*c4 + (n*(n+1)/2)*c5 + (n*(n-1)/2)*c6 + (n*(n-1)/2)*(c7+c8+c9+c10) + n*c11 + c12",
          "math_steps": "c1 + c2 + n*c3 + c3 + n*c4 + 0.5*n*n*c5 + 0.5*n*c5 + 0.5*n*n*c6 - 0.5*n*c6 + 0.5*n*n*(c7+c8+c9+c10) - 0.5*n*(c7+c8+c9+c10) + n*c11 + c12",
          "simplified_complexity": "(0.5*c5 + 0.5*c6 + 0.5*c7 + 0.5*c8 + 0.5*c9 + 0.5*c10)n^2 + (c3 + c4 + 0.5*c5 - 0.5*c6 - 0.5*c7 - 0.5*c8 - 0.5*c9 - 0.5*c10 + c11)n + (c1 + c2 + c3 + c12)",
          "complexity_class": "n^2",
          "notation_type": "O",
          "big_o": "O(n^2)",
          "trace_diagram": "graph TD\n    Start((Inicio)) --> InitVars[swapped = T, i = 0]\n    InitVars --> WhileCond{swapped = T?}\n    WhileCond -- SÃ­ --> ResetSwapped[swapped = F]\n    ResetSwapped --> ForLoopInit[j = 0]\n    ForLoopInit --> ForLoopCond{j < n - 1 - i?}\n    ForLoopCond -- SÃ­ --> IfCond{A[j] > A[j+1]?}\n    IfCond -- SÃ­ (Peor Caso) --> Swap[temp = A[j], A[j] = A[j+1], A[j+1] = temp]\n    Swap --> SetSwappedT[swapped = T]\n    SetSwappedT --> IncJ[j = j + 1]\n    IfCond -- No --> IncJ\n    IncJ --> ForLoopCond\n    ForLoopCond -- No --> IncI[i = i + 1]\n    IncI --> WhileCond\n    WhileCond -- No --> ReturnA[Return A]\n    ReturnA --> End((Fin))\n\n    Note right of WhileCond: El bucle 'while' se repite n veces.\n    Note right of ForLoopCond: El bucle 'for' se repite (n-1-i) veces en cada pasada.\n    Note right of IfCond: La condiciÃ³n A[j] > A[j+1] es casi siempre verdadera, forzando muchos intercambios."
        }
      ],
      "project_metadata": {
        "diagrams_generated": 2,
        "agent_model": "Gemini_Rapido",
        "optimization": "Full analysis"
      }
    }
  }
}