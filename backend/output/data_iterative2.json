{
  "input_metadata": {
    "source_type": "strict_code",
    "final_pseudocode": "        fibonacci(n)\n        begin\n            if (n <= 1) then\n            begin\n                return n\n            end\n            else\n            begin\n                CALL fibonacci(n-1)\n                CALL fibonacci(n-2)\n                return fib1 + fib2 \n            end\n        end"
  },
  "classification": {
    "type": "iterativo",
    "name": "Cálculo de la secuencia de Fibonacci (versión recursiva)"
  },
  "analysis": {
    "type": "iterativo",
    "code_explain": "El algoritmo de Fibonacci recursivo tiene un comportamiento exponencial debido a las llamadas recursivas. El caso base (n <= 1) tiene un costo constante, mientras que el caso recursivo realiza dos llamadas recursivas, lo que lleva a una complejidad de tiempo exponencial.",
    "complexity_line_to_line": [
      {
        "line": 1,
        "cost_constant": 1,
        "execution_count": "1",
        "total_cost_expression": "1 * 1"
      },
      {
        "line": 2,
        "cost_constant": 0,
        "execution_count": "1",
        "total_cost_expression": "0 * 1"
      },
      {
        "line": 3,
        "cost_constant": 3,
        "execution_count": "1",
        "total_cost_expression": "3 * 1"
      },
      {
        "line": 4,
        "cost_constant": 0,
        "execution_count": "1",
        "total_cost_expression": "0 * 1"
      },
      {
        "line": 5,
        "cost_constant": 1,
        "execution_count": "1",
        "total_cost_expression": "1 * 1"
      },
      {
        "line": 6,
        "cost_constant": 0,
        "execution_count": "1",
        "total_cost_expression": "0 * 1"
      },
      {
        "line": 7,
        "cost_constant": 0,
        "execution_count": "0",
        "total_cost_expression": "0 * 0"
      },
      {
        "line": 8,
        "cost_constant": 0,
        "execution_count": "0",
        "total_cost_expression": "0 * 0"
      },
      {
        "line": 9,
        "cost_constant": 2,
        "execution_count": "0",
        "total_cost_expression": "2 * 0"
      },
      {
        "line": 10,
        "cost_constant": 2,
        "execution_count": "0",
        "total_cost_expression": "2 * 0"
      },
      {
        "line": 11,
        "cost_constant": 2,
        "execution_count": "0",
        "total_cost_expression": "2 * 0"
      },
      {
        "line": 12,
        "cost_constant": 0,
        "execution_count": "0",
        "total_cost_expression": "0 * 0"
      },
      {
        "line": 13,
        "cost_constant": 0,
        "execution_count": "1",
        "total_cost_expression": "0 * 1"
      }
    ],
    "explain_complexity": "El algoritmo Cálculo de la secuencia de Fibonacci (versión recursiva) presenta diferentes complejidades según el caso: - Peor: O(f(n)) - Mejor: O(1)",
    "asymptotic_notation": {
      "worst": "O((1 + sqrt(3))^n)",
      "best": "Ω(1)",
      "explanation": "La versión recursiva del cálculo de Fibonacci presenta una complejidad exponencial en el peor caso debido a la duplicación de cálculos, mientras que en el mejor caso es constante."
    },
    "algorithm_name": "Cálculo de la secuencia de Fibonacci (versión recursiva)",
    "algorithm_category": "Iterativo / Bucle",
    "equation": [
      "Peor: 1 + 3 + 2*T(n-1) + 2*T(n-2) + 2",
      "Mejor: 1 + 3 + 1"
    ],
    "method_solution": "Método de Conteo de Pasos + Sumatorias",
    "solution_equation": [
      "Peor: T(n) = 2*T(n - 2) + 2*T(n - 1) + 6",
      "Mejor: T(n) = 5"
    ],
    "explain_solution_steps": [
      "**Peor**: 2*T(n - 2) + 2*T(n - 1) + 6",
      "**Mejor**: 5"
    ],
    "diagrams": {
      "main_flowchart": "graph TD\n    Start((Inicio)) --> CheckN{n <= 1?}\n    CheckN -- Sí --> ReturnN[Return n]\n    ReturnN --> End((Fin))"
    },
    "extra": {
      "is_case_dependent": true,
      "cases": [
        {
          "case_name": "Peor",
          "condition": "n > 1",
          "line_analysis": [
            {
              "line": 1,
              "cost_constant": 1,
              "execution_count": "1",
              "total_cost_expression": "1 * 1"
            },
            {
              "line": 2,
              "cost_constant": 0,
              "execution_count": "1",
              "total_cost_expression": "0 * 1"
            },
            {
              "line": 3,
              "cost_constant": 3,
              "execution_count": "1",
              "total_cost_expression": "3 * 1"
            },
            {
              "line": 4,
              "cost_constant": 0,
              "execution_count": "1",
              "total_cost_expression": "0 * 1"
            },
            {
              "line": 5,
              "cost_constant": 1,
              "execution_count": "0",
              "total_cost_expression": "1 * 0"
            },
            {
              "line": 6,
              "cost_constant": 0,
              "execution_count": "0",
              "total_cost_expression": "0 * 0"
            },
            {
              "line": 7,
              "cost_constant": 0,
              "execution_count": "1",
              "total_cost_expression": "0 * 1"
            },
            {
              "line": 8,
              "cost_constant": 0,
              "execution_count": "1",
              "total_cost_expression": "0 * 1"
            },
            {
              "line": 9,
              "cost_constant": 2,
              "execution_count": "T(n-1)",
              "total_cost_expression": "2 * T(n-1)"
            },
            {
              "line": 10,
              "cost_constant": 2,
              "execution_count": "T(n-2)",
              "total_cost_expression": "2 * T(n-2)"
            },
            {
              "line": 11,
              "cost_constant": 2,
              "execution_count": "1",
              "total_cost_expression": "2 * 1"
            },
            {
              "line": 12,
              "cost_constant": 0,
              "execution_count": "1",
              "total_cost_expression": "0 * 1"
            },
            {
              "line": 13,
              "cost_constant": 0,
              "execution_count": "1",
              "total_cost_expression": "0 * 1"
            }
          ],
          "raw_summation_str": "1 + 3 + 2*T(n-1) + 2*T(n-2) + 2",
          "math_steps": "2*T(n - 2) + 2*T(n - 1) + 6",
          "simplified_complexity": "2*T(n - 2) + 2*T(n - 1) + 6",
          "complexity_class": "(1 + sqrt(3))^n",
          "notation_type": "O",
          "big_o": "O((1 + sqrt(3))^n)",
          "trace_diagram": "graph TD\n    Start((Inicio)) --> CheckN{n <= 1?}\n    CheckN -- No --> CallN1[CALL fibonacci(n-1)]\n    CallN1 --> CallN2[CALL fibonacci(n-2)]\n    CallN2 --> SumReturn[Return fib1 + fib2]\n    SumReturn --> End((Fin))\n    CheckN -- Sí --> ReturnN[Return n]\n    ReturnN --> End\n    Note right of CallN1: Estas llamadas se repiten recursivamente hasta alcanzar el caso base (n <= 1)."
        },
        {
          "case_name": "Mejor",
          "condition": "n <= 1",
          "line_analysis": [
            {
              "line": 1,
              "cost_constant": 1,
              "execution_count": "1",
              "total_cost_expression": "1 * 1"
            },
            {
              "line": 2,
              "cost_constant": 0,
              "execution_count": "1",
              "total_cost_expression": "0 * 1"
            },
            {
              "line": 3,
              "cost_constant": 3,
              "execution_count": "1",
              "total_cost_expression": "3 * 1"
            },
            
            {
              "line": 4,
              "cost_constant": 0,
              "execution_count": "1",
              "total_cost_expression": "0 * 1"
            },
            {
              "line": 5,
              "cost_constant": 1,
              "execution_count": "1",
              "total_cost_expression": "1 * 1"
            },
            {
              "line": 6,
              "cost_constant": 0,
              "execution_count": "1",
              "total_cost_expression": "0 * 1"
            },
            {
              "line": 7,
              "cost_constant": 0,
              "execution_count": "0",
              "total_cost_expression": "0 * 0"
            },
            {
              "line": 8,
              "cost_constant": 0,
              "execution_count": "0",
              "total_cost_expression": "0 * 0"
            },
            {
              "line": 9,
              "cost_constant": 2,
              "execution_count": "0",
              "total_cost_expression": "2 * 0"
            },
            {
              "line": 10,
              "cost_constant": 2,
              "execution_count": "0",
              "total_cost_expression": "2 * 0"
            },
            {
              "line": 11,
              "cost_constant": 2,
              "execution_count": "0",
              "total_cost_expression": "2 * 0"
            },
            {
              "line": 12,
              "cost_constant": 0,
              "execution_count": "0",
              "total_cost_expression": "0 * 0"
            },
            {
              "line": 13,
              "cost_constant": 0,
              "execution_count": "1",
              "total_cost_expression": "0 * 1"
            }
          ],
          "raw_summation_str": "1 + 3 + 1",
          "math_steps": "5",
          "simplified_complexity": "5",
          "complexity_class": "1",
          "notation_type": "Ω",
          "big_o": "Ω(1)",
          "trace_diagram": "graph TD\n    Start((Inicio)) --> CheckN{n <= 1?}\n    CheckN -- Sí --> ReturnN[Return n]\n    ReturnN --> End((Fin))"
        }
      ],
      "project_metadata": {
        "diagrams_generated": 2,
        "agent_model": "Gemini_Rapido",
        "optimization": "Full analysis"
      }
    }
  }
}