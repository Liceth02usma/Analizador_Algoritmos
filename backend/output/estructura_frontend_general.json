{
  "type": "Recursivo",
  "code_explain": "Este algoritmo implementa la búsqueda binaria recursiva. Divide repetidamente el espacio de búsqueda a la mitad hasta que encuentra el elemento o el espacio de búsqueda se vuelve vacío.",
  "complexity_line_to_line": "=== MEJOR CASO ===\nbinary_search(A, left, right, x)\nbegin\n    if (left > right) then  // c1\n    begin\n        return -1  // c2\n    end\n\n    mid ⬤ ⌊(left + right) / 2⌋  // c3\n\n    if (A[mid] = x) then  // c4\n    begin\n    begin\n        return mid  // c5\n    end\n    else begin\n        if (A[mid] > x) then  // c6\n        begin\n            return CALL binary_search(A, left, mid - 1, x)  // T(n/2)\n        end\n        else begin\n            return CALL binary_search(A, mid + 1, right, x)  // T(n/2)\n        end\n    end\nend\n\n=== PEOR CASO ===\nbinary_search(A, left, right, x)\nbegin\n    if (left > right) then  // c1\n    begin\n        return -1  // c2\n    end\n\n    mid ⬤ ⌊(left + right) / 2⌋  // c3\n\n    if (A[mid] = x) then  // c4\n    begin\n    begin\n        return mid  // c5\n    end\n    else begin\n        if (A[mid] > x) then  // c6\n        begin\n            return CALL binary_search(A, left, mid - 1, x)  // T(n/2)\n        end\n        else begin\n            return CALL binary_search(A, mid + 1, right, x)  // T(n/2)\n        end\n    end\nend\n\n=== CASO PROMEDIO ===\nbinary_search(A, left, right, x)\nbegin\n    if (left > right) then  // c1\n    begin\n        return -1  // c2\n    end\n\n    mid ⬤ ⌊(left + right) / 2⌋  // c3\n\n    if (A[mid] = x) then  // c4\n    begin\n    begin\n        return mid  // c5\n    end\n    else begin\n        if (A[mid] > x) then  // c6\n        begin\n            return CALL binary_search(A, left, mid - 1, x)  // T(n/2)\n        end\n        else begin\n            return CALL binary_search(A, mid + 1, right, x)  // T(n/2)\n        end\n    end\nend",
  "explain_complexity": "Mejor caso: Sea 'n' el tamaño del arreglo (right - left + 1). En cada llamada recursiva, el algoritmo realiza un número constante de operaciones (comparaciones, asignaciones, aritmética) y luego se llama a sí mismo con un problema de tamaño 'n/2'.\n\nLa relación de recurrencia es: T(n) = T(n/2) + C_0, donde C_0 es la suma de los costes constantes (c1 + c3 + c4 + c6 en el peor caso, o c1 + c3 + c4 en el mejor caso de encontrarlo en la primera llamada, o c1 + c2 en el caso base de no encontrarlo).\n\nDesarrollando la recurrencia:\nT(n) = T(n/2) + C_0\nT(n) = (T(n/4) + C_0) + C_0 = T(n/4) + 2C_0\nT(n) = (T(n/8) + C_0) + 2C_0 = T(n/8) + 3C_0\n...\nT(n) = T(n/2^k) + k * C_0\n\nLa recursión termina cuando el tamaño del subproblema es 1 (n/2^k = 1), lo que implica k = log_2(n).\nSustituyendo k:\nT(n) = T(1) + log_2(n) * C_0\n\nDonde T(1) es el costo del caso base (una constante, por ejemplo, c1 + c2 o c1 + c3 + c4 + c5).\n\nPor lo tanto, el costo total es dominado por el término log_2(n).\n\nPeor caso: Sea 'n' el tamaño del arreglo (right - left + 1). En cada llamada recursiva, el algoritmo realiza un número constante de operaciones (comparaciones, asignaciones, aritmética) y luego se llama a sí mismo con un problema de tamaño 'n/2'.\n\nLa relación de recurrencia es: T(n) = T(n/2) + C_0, donde C_0 es la suma de los costes constantes (c1 + c3 + c4 + c6 en el peor caso, o c1 + c3 + c4 en el mejor caso de encontrarlo en la primera llamada, o c1 + c2 en el caso base de no encontrarlo).\n\nDesarrollando la recurrencia:\nT(n) = T(n/2) + C_0\nT(n) = (T(n/4) + C_0) + C_0 = T(n/4) + 2C_0\nT(n) = (T(n/8) + C_0) + 2C_0 = T(n/8) + 3C_0\n...\nT(n) = T(n/2^k) + k * C_0\n\nLa recursión termina cuando el tamaño del subproblema es 1 (n/2^k = 1), lo que implica k = log_2(n).\nSustituyendo k:\nT(n) = T(1) + log_2(n) * C_0\n\nDonde T(1) es el costo del caso base (una constante, por ejemplo, c1 + c2 o c1 + c3 + c4 + c5).\n\nPor lo tanto, el costo total es dominado por el término log_2(n).\n\nCaso promedio: Sea 'n' el tamaño del arreglo (right - left + 1). En cada llamada recursiva, el algoritmo realiza un número constante de operaciones (comparaciones, asignaciones, aritmética) y luego se llama a sí mismo con un problema de tamaño 'n/2'.\n\nLa relación de recurrencia es: T(n) = T(n/2) + C_0, donde C_0 es la suma de los costes constantes (c1 + c3 + c4 + c6 en el peor caso, o c1 + c3 + c4 en el mejor caso de encontrarlo en la primera llamada, o c1 + c2 en el caso base de no encontrarlo).\n\nDesarrollando la recurrencia:\nT(n) = T(n/2) + C_0\nT(n) = (T(n/4) + C_0) + C_0 = T(n/4) + 2C_0\nT(n) = (T(n/8) + C_0) + 2C_0 = T(n/8) + 3C_0\n...\nT(n) = T(n/2^k) + k * C_0\n\nLa recursión termina cuando el tamaño del subproblema es 1 (n/2^k = 1), lo que implica k = log_2(n).\nSustituyendo k:\nT(n) = T(1) + log_2(n) * C_0\n\nDonde T(1) es el costo del caso base (una constante, por ejemplo, c1 + c2 o c1 + c3 + c4 + c5).\n\nPor lo tanto, el costo total es dominado por el término log_2(n).",
  "asymptotic_notation": {
    "explanation": "El algoritmo No se tiene una complejidad temporal de O(log n) en el peor caso.",
    "best": "Ω(log n)",
    "worst": "O(log n)",
    "average": "Θ(log n)"
  },
  "algorithm_name": "No se",
  "algorithm_category": "Recursivo",
  "equation": [
    "T(n) = T(n/2) + 1, T(1) = 1",
    "T(n) = T(n/2) + 1, T(1) = 1",
    "T(n) = T(n/2) + 1, T(1) = 1"
  ],
  "method_solution": [
    "master_theorem",
    "master_theorem",
    "master_theorem"
  ],
  "solution_equation": [
    "log n",
    "log n",
    "log n"
  ],
  "explain_solution_steps": [
    {
      "case_type": "best_case",
      "equation": "T(n) = T(n/2) + 1, T(1) = 1",
      "original_equation": "T(n) = T(n/2) + 1, T(1) = 1",
      "simplification": null,
      "method": "master_theorem",
      "method_enum": "master_theorem",
      "complexity": "log n",
      "steps": [
        "**Paso 1 - Parámetros:**",
        " a = 1, b = 2",
        " f(n) = 1",
        "",
        "**Paso 2 - Exponente Crítico:**",
        " log_2(1) ≈ n^0",
        "",
        "**Paso 3 - Análisis de Límite (SymPy):**",
        " f(n) y n^0 crecen a la misma velocidad.",
        "",
        "**Paso 4 - Conclusión:**",
        " Aplica **Caso 2**",
        " Término dominante: log n"
      ],
      "explanation": "1.  **Identificación de Parámetros:**\n    *   `a = 1`: Indica que cada problema se divide en 1 subproblema.\n    *   `b = 2`: Indica que el tamaño de cada subproblema es `n/2`.\n    *   `f(n) = 1`: Representa el costo del trabajo adicional (dividir y combinar) en cada nivel de la recursión, que es una constante.\n\n2.  **Cálculo del Exponente Crítico (E):**\n    *   Calculamos `E = log_b a`.\n    *   Sustituyendo los valores: `E = log_2 1`.\n    *   Sabemos que cualquier número elevado a la potencia de 0 es 1, por lo tanto, `log_2 1 = 0`.\n    *   Así, el término `n^E` es `n^0`, que es igual a `1`.\n\n3.  **Análisis del Límite (Comparación de f(n) con n^E):**\n    *   Ahora comparamos `f(n)` con `n^E` calculando el límite: `lim (f(n) / n^E)` cuando `n` tiende a infinito.\n    *   Sustituyendo los valores: `lim (1 / 1)` cuando `n` tiende a infinito.\n    *   El límite es `1` (una constante).\n\n4.  **Interpretación del Límite y Determinación del Caso:**\n    *   Dado que el límite es una constante (no 0 ni infinito), esto significa que `f(n)` y `n^E` (es decir, `1` y `1`) crecen a la misma velocidad asintóticamente.\n    *   Esta situación corresponde al **Caso 2** del Teorema Maestro.\n\n5.  **Conclusión de la Complejidad:**\n    *   Para el Caso 2, la complejidad se define como `n^E * log n`.\n    *   Sustituyendo `E = 0`: `n^0 * log n`.\n    *   Como `n^0 = 1`, la complejidad final es `1 * log n`, que se simplifica a `log n`.",
      "details": {
        "complexity": "log n",
        "steps": [
          "**Paso 1 - Parámetros:**",
          " a = 1, b = 2",
          " f(n) = 1",
          "",
          "**Paso 2 - Exponente Crítico:**",
          " log_2(1) ≈ n^0",
          "",
          "**Paso 3 - Análisis de Límite (SymPy):**",
          " f(n) y n^0 crecen a la misma velocidad.",
          "",
          "**Paso 4 - Conclusión:**",
          " Aplica **Caso 2**",
          " Término dominante: log n"
        ],
        "explanation": "1.  **Identificación de Parámetros:**\n    *   `a = 1`: Indica que cada problema se divide en 1 subproblema.\n    *   `b = 2`: Indica que el tamaño de cada subproblema es `n/2`.\n    *   `f(n) = 1`: Representa el costo del trabajo adicional (dividir y combinar) en cada nivel de la recursión, que es una constante.\n\n2.  **Cálculo del Exponente Crítico (E):**\n    *   Calculamos `E = log_b a`.\n    *   Sustituyendo los valores: `E = log_2 1`.\n    *   Sabemos que cualquier número elevado a la potencia de 0 es 1, por lo tanto, `log_2 1 = 0`.\n    *   Así, el término `n^E` es `n^0`, que es igual a `1`.\n\n3.  **Análisis del Límite (Comparación de f(n) con n^E):**\n    *   Ahora comparamos `f(n)` con `n^E` calculando el límite: `lim (f(n) / n^E)` cuando `n` tiende a infinito.\n    *   Sustituyendo los valores: `lim (1 / 1)` cuando `n` tiende a infinito.\n    *   El límite es `1` (una constante).\n\n4.  **Interpretación del Límite y Determinación del Caso:**\n    *   Dado que el límite es una constante (no 0 ni infinito), esto significa que `f(n)` y `n^E` (es decir, `1` y `1`) crecen a la misma velocidad asintóticamente.\n    *   Esta situación corresponde al **Caso 2** del Teorema Maestro.\n\n5.  **Conclusión de la Complejidad:**\n    *   Para el Caso 2, la complejidad se define como `n^E * log n`.\n    *   Sustituyendo `E = 0`: `n^0 * log n`.\n    *   Como `n^0 = 1`, la complejidad final es `1 * log n`, que se simplifica a `log n`.",
        "applicable": true,
        "method": "Teorema Maestro",
        "case": "Caso 2",
        "a": 1,
        "b": 2,
        "log_b_a": "n^0"
      },
      "classification_confidence": 0.95,
      "classification_reasoning": "Ecuación en forma T(n) = aT(n/2) + f(n). Divide el problema en 1 subproblema(s) de tamaño n/2. Trabajo adicional: =+1,=1. El Teorema Maestro es el método óptimo."
    },
    {
      "case_type": "worst_case",
      "equation": "T(n) = T(n/2) + 1, T(1) = 1",
      "original_equation": "T(n) = T(n/2) + 1, T(1) = 1",
      "simplification": null,
      "method": "master_theorem",
      "method_enum": "master_theorem",
      "complexity": "log n",
      "steps": [
        "**Paso 1 - Parámetros:**",
        " a = 1, b = 2",
        " f(n) = 1",
        "",
        "**Paso 2 - Exponente Crítico:**",
        " log_2(1) ≈ n^0",
        "",
        "**Paso 3 - Análisis de Límite (SymPy):**",
        " f(n) y n^0 crecen a la misma velocidad.",
        "",
        "**Paso 4 - Conclusión:**",
        " Aplica **Caso 2**",
        " Término dominante: log n"
      ],
      "explanation": "1.  **Identificación de Parámetros:**\n    *   `a = 1`: Indica que cada problema se divide en 1 subproblema.\n    *   `b = 2`: Indica que el tamaño de cada subproblema es `n/2`.\n    *   `f(n) = 1`: Representa el costo del trabajo adicional (dividir y combinar) en cada nivel de la recursión, que es una constante.\n\n2.  **Cálculo del Exponente Crítico (E):**\n    *   Calculamos `E = log_b a`.\n    *   Sustituyendo los valores: `E = log_2 1`.\n    *   Sabemos que cualquier número elevado a la potencia de 0 es 1, por lo tanto, `log_2 1 = 0`.\n    *   Así, el término `n^E` es `n^0`, que es igual a `1`.\n\n3.  **Análisis del Límite (Comparación de f(n) con n^E):**\n    *   Ahora comparamos `f(n)` con `n^E` calculando el límite: `lim (f(n) / n^E)` cuando `n` tiende a infinito.\n    *   Sustituyendo los valores: `lim (1 / 1)` cuando `n` tiende a infinito.\n    *   El límite es `1` (una constante).\n\n4.  **Interpretación del Límite y Determinación del Caso:**\n    *   Dado que el límite es una constante (no 0 ni infinito), esto significa que `f(n)` y `n^E` (es decir, `1` y `1`) crecen a la misma velocidad asintóticamente.\n    *   Esta situación corresponde al **Caso 2** del Teorema Maestro.\n\n5.  **Conclusión de la Complejidad:**\n    *   Para el Caso 2, la complejidad se define como `n^E * log n`.\n    *   Sustituyendo `E = 0`: `n^0 * log n`.\n    *   Como `n^0 = 1`, la complejidad final es `1 * log n`, que se simplifica a `log n`.",
      "details": {
        "complexity": "log n",
        "steps": [
          "**Paso 1 - Parámetros:**",
          " a = 1, b = 2",
          " f(n) = 1",
          "",
          "**Paso 2 - Exponente Crítico:**",
          " log_2(1) ≈ n^0",
          "",
          "**Paso 3 - Análisis de Límite (SymPy):**",
          " f(n) y n^0 crecen a la misma velocidad.",
          "",
          "**Paso 4 - Conclusión:**",
          " Aplica **Caso 2**",
          " Término dominante: log n"
        ],
        "explanation": "1.  **Identificación de Parámetros:**\n    *   `a = 1`: Indica que cada problema se divide en 1 subproblema.\n    *   `b = 2`: Indica que el tamaño de cada subproblema es `n/2`.\n    *   `f(n) = 1`: Representa el costo del trabajo adicional (dividir y combinar) en cada nivel de la recursión, que es una constante.\n\n2.  **Cálculo del Exponente Crítico (E):**\n    *   Calculamos `E = log_b a`.\n    *   Sustituyendo los valores: `E = log_2 1`.\n    *   Sabemos que cualquier número elevado a la potencia de 0 es 1, por lo tanto, `log_2 1 = 0`.\n    *   Así, el término `n^E` es `n^0`, que es igual a `1`.\n\n3.  **Análisis del Límite (Comparación de f(n) con n^E):**\n    *   Ahora comparamos `f(n)` con `n^E` calculando el límite: `lim (f(n) / n^E)` cuando `n` tiende a infinito.\n    *   Sustituyendo los valores: `lim (1 / 1)` cuando `n` tiende a infinito.\n    *   El límite es `1` (una constante).\n\n4.  **Interpretación del Límite y Determinación del Caso:**\n    *   Dado que el límite es una constante (no 0 ni infinito), esto significa que `f(n)` y `n^E` (es decir, `1` y `1`) crecen a la misma velocidad asintóticamente.\n    *   Esta situación corresponde al **Caso 2** del Teorema Maestro.\n\n5.  **Conclusión de la Complejidad:**\n    *   Para el Caso 2, la complejidad se define como `n^E * log n`.\n    *   Sustituyendo `E = 0`: `n^0 * log n`.\n    *   Como `n^0 = 1`, la complejidad final es `1 * log n`, que se simplifica a `log n`.",
        "applicable": true,
        "method": "Teorema Maestro",
        "case": "Caso 2",
        "a": 1,
        "b": 2,
        "log_b_a": "n^0"
      },
      "classification_confidence": 0.95,
      "classification_reasoning": "Ecuación en forma T(n) = aT(n/2) + f(n). Divide el problema en 1 subproblema(s) de tamaño n/2. Trabajo adicional: =+1,=1. El Teorema Maestro es el método óptimo."
    },
    {
      "case_type": "average_case",
      "equation": "T(n) = T(n/2) + 1, T(1) = 1",
      "original_equation": "T(n) = T(n/2) + 1, T(1) = 1",
      "simplification": null,
      "method": "master_theorem",
      "method_enum": "master_theorem",
      "complexity": "log n",
      "steps": [
        "**Paso 1 - Parámetros:**",
        " a = 1, b = 2",
        " f(n) = 1",
        "",
        "**Paso 2 - Exponente Crítico:**",
        " log_2(1) ≈ n^0",
        "",
        "**Paso 3 - Análisis de Límite (SymPy):**",
        " f(n) y n^0 crecen a la misma velocidad.",
        "",
        "**Paso 4 - Conclusión:**",
        " Aplica **Caso 2**",
        " Término dominante: log n"
      ],
      "explanation": "1.  **Identificación de Parámetros:**\n    *   `a = 1`: Indica que cada problema se divide en 1 subproblema.\n    *   `b = 2`: Indica que el tamaño de cada subproblema es `n/2`.\n    *   `f(n) = 1`: Representa el costo del trabajo adicional (dividir y combinar) en cada nivel de la recursión, que es una constante.\n\n2.  **Cálculo del Exponente Crítico (E):**\n    *   Calculamos `E = log_b a`.\n    *   Sustituyendo los valores: `E = log_2 1`.\n    *   Sabemos que cualquier número elevado a la potencia de 0 es 1, por lo tanto, `log_2 1 = 0`.\n    *   Así, el término `n^E` es `n^0`, que es igual a `1`.\n\n3.  **Análisis del Límite (Comparación de f(n) con n^E):**\n    *   Ahora comparamos `f(n)` con `n^E` calculando el límite: `lim (f(n) / n^E)` cuando `n` tiende a infinito.\n    *   Sustituyendo los valores: `lim (1 / 1)` cuando `n` tiende a infinito.\n    *   El límite es `1` (una constante).\n\n4.  **Interpretación del Límite y Determinación del Caso:**\n    *   Dado que el límite es una constante (no 0 ni infinito), esto significa que `f(n)` y `n^E` (es decir, `1` y `1`) crecen a la misma velocidad asintóticamente.\n    *   Esta situación corresponde al **Caso 2** del Teorema Maestro.\n\n5.  **Conclusión de la Complejidad:**\n    *   Para el Caso 2, la complejidad se define como `n^E * log n`.\n    *   Sustituyendo `E = 0`: `n^0 * log n`.\n    *   Como `n^0 = 1`, la complejidad final es `1 * log n`, que se simplifica a `log n`.",
      "details": {
        "complexity": "log n",
        "steps": [
          "**Paso 1 - Parámetros:**",
          " a = 1, b = 2",
          " f(n) = 1",
          "",
          "**Paso 2 - Exponente Crítico:**",
          " log_2(1) ≈ n^0",
          "",
          "**Paso 3 - Análisis de Límite (SymPy):**",
          " f(n) y n^0 crecen a la misma velocidad.",
          "",
          "**Paso 4 - Conclusión:**",
          " Aplica **Caso 2**",
          " Término dominante: log n"
        ],
        "explanation": "1.  **Identificación de Parámetros:**\n    *   `a = 1`: Indica que cada problema se divide en 1 subproblema.\n    *   `b = 2`: Indica que el tamaño de cada subproblema es `n/2`.\n    *   `f(n) = 1`: Representa el costo del trabajo adicional (dividir y combinar) en cada nivel de la recursión, que es una constante.\n\n2.  **Cálculo del Exponente Crítico (E):**\n    *   Calculamos `E = log_b a`.\n    *   Sustituyendo los valores: `E = log_2 1`.\n    *   Sabemos que cualquier número elevado a la potencia de 0 es 1, por lo tanto, `log_2 1 = 0`.\n    *   Así, el término `n^E` es `n^0`, que es igual a `1`.\n\n3.  **Análisis del Límite (Comparación de f(n) con n^E):**\n    *   Ahora comparamos `f(n)` con `n^E` calculando el límite: `lim (f(n) / n^E)` cuando `n` tiende a infinito.\n    *   Sustituyendo los valores: `lim (1 / 1)` cuando `n` tiende a infinito.\n    *   El límite es `1` (una constante).\n\n4.  **Interpretación del Límite y Determinación del Caso:**\n    *   Dado que el límite es una constante (no 0 ni infinito), esto significa que `f(n)` y `n^E` (es decir, `1` y `1`) crecen a la misma velocidad asintóticamente.\n    *   Esta situación corresponde al **Caso 2** del Teorema Maestro.\n\n5.  **Conclusión de la Complejidad:**\n    *   Para el Caso 2, la complejidad se define como `n^E * log n`.\n    *   Sustituyendo `E = 0`: `n^0 * log n`.\n    *   Como `n^0 = 1`, la complejidad final es `1 * log n`, que se simplifica a `log n`.",
        "applicable": true,
        "method": "Teorema Maestro",
        "case": "Caso 2",
        "a": 1,
        "b": 2,
        "log_b_a": "n^0"
      },
      "classification_confidence": 0.95,
      "classification_reasoning": "Ecuación en forma T(n) = aT(n/2) + f(n). Divide el problema en 1 subproblema(s) de tamaño n/2. Trabajo adicional: =+1,=1. El Teorema Maestro es el método óptimo."
    }
  ],
  "diagrams": {
    "tree_method_best_case": "graph TD\n    %% Estilos\n    classDef root fill:#f9f,stroke:#333,stroke-width:2px;\n    classDef leaf fill:#dfd,stroke:#333,stroke-width:1px;\n    classDef node fill:#fff,stroke:#333,stroke-width:1px;\n\n    subgraph cluster_0 [\"SINGLE: T(n) = T(n/2) + 1\"]\n    direction TB\n    T0_L0_P0(\"T(n)\"):::root\n    T0_L1_P0(\"T(n/2)\"):::node\n    T0_L0_P0 --> T0_L1_P0\n    T0_L2_P0(\"T(n/4)\"):::node\n    T0_L1_P0 --> T0_L2_P0\n    T0_L3_P0(\"T(n/8)\"):::leaf\n    T0_L2_P0 --> T0_L3_P0\n    end",
    "tree_method_worst_case": "graph TD\n    %% Estilos\n    classDef root fill:#f9f,stroke:#333,stroke-width:2px;\n    classDef leaf fill:#dfd,stroke:#333,stroke-width:1px;\n    classDef node fill:#fff,stroke:#333,stroke-width:1px;\n\n    subgraph cluster_0 [\"SINGLE: T(n) = T(n/2) + 1\"]\n    direction TB\n    T0_L0_P0(\"T(n)\"):::root\n    T0_L1_P0(\"T(n/2)\"):::node\n    T0_L0_P0 --> T0_L1_P0\n    T0_L2_P0(\"T(n/4)\"):::node\n    T0_L1_P0 --> T0_L2_P0\n    T0_L3_P0(\"T(n/8)\"):::leaf\n    T0_L2_P0 --> T0_L3_P0\n    end",
    "tree_method_average_case": "graph TD\n    %% Estilos\n    classDef root fill:#f9f,stroke:#333,stroke-width:2px;\n    classDef leaf fill:#dfd,stroke:#333,stroke-width:1px;\n    classDef node fill:#fff,stroke:#333,stroke-width:1px;\n\n    subgraph cluster_0 [\"SINGLE: T(n) = T(n/2) + 1\"]\n    direction TB\n    T0_L0_P0(\"T(n)\"):::root\n    T0_L1_P0(\"T(n/2)\"):::node\n    T0_L0_P0 --> T0_L1_P0\n    T0_L2_P0(\"T(n/4)\"):::node\n    T0_L1_P0 --> T0_L2_P0\n    T0_L3_P0(\"T(n/8)\"):::leaf\n    T0_L2_P0 --> T0_L3_P0\n    end"
  },
  "extra": {
    "has_multiple_cases": false,
    "analysis_details": [
      {
        "case_type": "best_case",
        "equation": "T(n) = T(n/2) + 1, T(1) = 1",
        "original_equation": "T(n) = T(n/2) + 1, T(1) = 1",
        "simplification": null,
        "method": "master_theorem",
        "method_enum": "master_theorem",
        "complexity": "log n",
        "steps": [
          "**Paso 1 - Parámetros:**",
          " a = 1, b = 2",
          " f(n) = 1",
          "",
          "**Paso 2 - Exponente Crítico:**",
          " log_2(1) ≈ n^0",
          "",
          "**Paso 3 - Análisis de Límite (SymPy):**",
          " f(n) y n^0 crecen a la misma velocidad.",
          "",
          "**Paso 4 - Conclusión:**",
          " Aplica **Caso 2**",
          " Término dominante: log n"
        ],
        "explanation": "1.  **Identificación de Parámetros:**\n    *   `a = 1`: Indica que cada problema se divide en 1 subproblema.\n    *   `b = 2`: Indica que el tamaño de cada subproblema es `n/2`.\n    *   `f(n) = 1`: Representa el costo del trabajo adicional (dividir y combinar) en cada nivel de la recursión, que es una constante.\n\n2.  **Cálculo del Exponente Crítico (E):**\n    *   Calculamos `E = log_b a`.\n    *   Sustituyendo los valores: `E = log_2 1`.\n    *   Sabemos que cualquier número elevado a la potencia de 0 es 1, por lo tanto, `log_2 1 = 0`.\n    *   Así, el término `n^E` es `n^0`, que es igual a `1`.\n\n3.  **Análisis del Límite (Comparación de f(n) con n^E):**\n    *   Ahora comparamos `f(n)` con `n^E` calculando el límite: `lim (f(n) / n^E)` cuando `n` tiende a infinito.\n    *   Sustituyendo los valores: `lim (1 / 1)` cuando `n` tiende a infinito.\n    *   El límite es `1` (una constante).\n\n4.  **Interpretación del Límite y Determinación del Caso:**\n    *   Dado que el límite es una constante (no 0 ni infinito), esto significa que `f(n)` y `n^E` (es decir, `1` y `1`) crecen a la misma velocidad asintóticamente.\n    *   Esta situación corresponde al **Caso 2** del Teorema Maestro.\n\n5.  **Conclusión de la Complejidad:**\n    *   Para el Caso 2, la complejidad se define como `n^E * log n`.\n    *   Sustituyendo `E = 0`: `n^0 * log n`.\n    *   Como `n^0 = 1`, la complejidad final es `1 * log n`, que se simplifica a `log n`.",
        "details": {
          "complexity": "log n",
          "steps": [
            "**Paso 1 - Parámetros:**",
            " a = 1, b = 2",
            " f(n) = 1",
            "",
            "**Paso 2 - Exponente Crítico:**",
            " log_2(1) ≈ n^0",
            "",
            "**Paso 3 - Análisis de Límite (SymPy):**",
            " f(n) y n^0 crecen a la misma velocidad.",
            "",
            "**Paso 4 - Conclusión:**",
            " Aplica **Caso 2**",
            " Término dominante: log n"
          ],
          "explanation": "1.  **Identificación de Parámetros:**\n    *   `a = 1`: Indica que cada problema se divide en 1 subproblema.\n    *   `b = 2`: Indica que el tamaño de cada subproblema es `n/2`.\n    *   `f(n) = 1`: Representa el costo del trabajo adicional (dividir y combinar) en cada nivel de la recursión, que es una constante.\n\n2.  **Cálculo del Exponente Crítico (E):**\n    *   Calculamos `E = log_b a`.\n    *   Sustituyendo los valores: `E = log_2 1`.\n    *   Sabemos que cualquier número elevado a la potencia de 0 es 1, por lo tanto, `log_2 1 = 0`.\n    *   Así, el término `n^E` es `n^0`, que es igual a `1`.\n\n3.  **Análisis del Límite (Comparación de f(n) con n^E):**\n    *   Ahora comparamos `f(n)` con `n^E` calculando el límite: `lim (f(n) / n^E)` cuando `n` tiende a infinito.\n    *   Sustituyendo los valores: `lim (1 / 1)` cuando `n` tiende a infinito.\n    *   El límite es `1` (una constante).\n\n4.  **Interpretación del Límite y Determinación del Caso:**\n    *   Dado que el límite es una constante (no 0 ni infinito), esto significa que `f(n)` y `n^E` (es decir, `1` y `1`) crecen a la misma velocidad asintóticamente.\n    *   Esta situación corresponde al **Caso 2** del Teorema Maestro.\n\n5.  **Conclusión de la Complejidad:**\n    *   Para el Caso 2, la complejidad se define como `n^E * log n`.\n    *   Sustituyendo `E = 0`: `n^0 * log n`.\n    *   Como `n^0 = 1`, la complejidad final es `1 * log n`, que se simplifica a `log n`.",
          "applicable": true,
          "method": "Teorema Maestro",
          "case": "Caso 2",
          "a": 1,
          "b": 2,
          "log_b_a": "n^0"
        },
        "classification_confidence": 0.95,
        "classification_reasoning": "Ecuación en forma T(n) = aT(n/2) + f(n). Divide el problema en 1 subproblema(s) de tamaño n/2. Trabajo adicional: =+1,=1. El Teorema Maestro es el método óptimo."
      },
      {
        "case_type": "worst_case",
        "equation": "T(n) = T(n/2) + 1, T(1) = 1",
        "original_equation": "T(n) = T(n/2) + 1, T(1) = 1",
        "simplification": null,
        "method": "master_theorem",
        "method_enum": "master_theorem",
        "complexity": "log n",
        "steps": [
          "**Paso 1 - Parámetros:**",
          " a = 1, b = 2",
          " f(n) = 1",
          "",
          "**Paso 2 - Exponente Crítico:**",
          " log_2(1) ≈ n^0",
          "",
          "**Paso 3 - Análisis de Límite (SymPy):**",
          " f(n) y n^0 crecen a la misma velocidad.",
          "",
          "**Paso 4 - Conclusión:**",
          " Aplica **Caso 2**",
          " Término dominante: log n"
        ],
        "explanation": "1.  **Identificación de Parámetros:**\n    *   `a = 1`: Indica que cada problema se divide en 1 subproblema.\n    *   `b = 2`: Indica que el tamaño de cada subproblema es `n/2`.\n    *   `f(n) = 1`: Representa el costo del trabajo adicional (dividir y combinar) en cada nivel de la recursión, que es una constante.\n\n2.  **Cálculo del Exponente Crítico (E):**\n    *   Calculamos `E = log_b a`.\n    *   Sustituyendo los valores: `E = log_2 1`.\n    *   Sabemos que cualquier número elevado a la potencia de 0 es 1, por lo tanto, `log_2 1 = 0`.\n    *   Así, el término `n^E` es `n^0`, que es igual a `1`.\n\n3.  **Análisis del Límite (Comparación de f(n) con n^E):**\n    *   Ahora comparamos `f(n)` con `n^E` calculando el límite: `lim (f(n) / n^E)` cuando `n` tiende a infinito.\n    *   Sustituyendo los valores: `lim (1 / 1)` cuando `n` tiende a infinito.\n    *   El límite es `1` (una constante).\n\n4.  **Interpretación del Límite y Determinación del Caso:**\n    *   Dado que el límite es una constante (no 0 ni infinito), esto significa que `f(n)` y `n^E` (es decir, `1` y `1`) crecen a la misma velocidad asintóticamente.\n    *   Esta situación corresponde al **Caso 2** del Teorema Maestro.\n\n5.  **Conclusión de la Complejidad:**\n    *   Para el Caso 2, la complejidad se define como `n^E * log n`.\n    *   Sustituyendo `E = 0`: `n^0 * log n`.\n    *   Como `n^0 = 1`, la complejidad final es `1 * log n`, que se simplifica a `log n`.",
        "details": {
          "complexity": "log n",
          "steps": [
            "**Paso 1 - Parámetros:**",
            " a = 1, b = 2",
            " f(n) = 1",
            "",
            "**Paso 2 - Exponente Crítico:**",
            " log_2(1) ≈ n^0",
            "",
            "**Paso 3 - Análisis de Límite (SymPy):**",
            " f(n) y n^0 crecen a la misma velocidad.",
            "",
            "**Paso 4 - Conclusión:**",
            " Aplica **Caso 2**",
            " Término dominante: log n"
          ],
          "explanation": "1.  **Identificación de Parámetros:**\n    *   `a = 1`: Indica que cada problema se divide en 1 subproblema.\n    *   `b = 2`: Indica que el tamaño de cada subproblema es `n/2`.\n    *   `f(n) = 1`: Representa el costo del trabajo adicional (dividir y combinar) en cada nivel de la recursión, que es una constante.\n\n2.  **Cálculo del Exponente Crítico (E):**\n    *   Calculamos `E = log_b a`.\n    *   Sustituyendo los valores: `E = log_2 1`.\n    *   Sabemos que cualquier número elevado a la potencia de 0 es 1, por lo tanto, `log_2 1 = 0`.\n    *   Así, el término `n^E` es `n^0`, que es igual a `1`.\n\n3.  **Análisis del Límite (Comparación de f(n) con n^E):**\n    *   Ahora comparamos `f(n)` con `n^E` calculando el límite: `lim (f(n) / n^E)` cuando `n` tiende a infinito.\n    *   Sustituyendo los valores: `lim (1 / 1)` cuando `n` tiende a infinito.\n    *   El límite es `1` (una constante).\n\n4.  **Interpretación del Límite y Determinación del Caso:**\n    *   Dado que el límite es una constante (no 0 ni infinito), esto significa que `f(n)` y `n^E` (es decir, `1` y `1`) crecen a la misma velocidad asintóticamente.\n    *   Esta situación corresponde al **Caso 2** del Teorema Maestro.\n\n5.  **Conclusión de la Complejidad:**\n    *   Para el Caso 2, la complejidad se define como `n^E * log n`.\n    *   Sustituyendo `E = 0`: `n^0 * log n`.\n    *   Como `n^0 = 1`, la complejidad final es `1 * log n`, que se simplifica a `log n`.",
          "applicable": true,
          "method": "Teorema Maestro",
          "case": "Caso 2",
          "a": 1,
          "b": 2,
          "log_b_a": "n^0"
        },
        "classification_confidence": 0.95,
        "classification_reasoning": "Ecuación en forma T(n) = aT(n/2) + f(n). Divide el problema en 1 subproblema(s) de tamaño n/2. Trabajo adicional: =+1,=1. El Teorema Maestro es el método óptimo."
      },
      {
        "case_type": "average_case",
        "equation": "T(n) = T(n/2) + 1, T(1) = 1",
        "original_equation": "T(n) = T(n/2) + 1, T(1) = 1",
        "simplification": null,
        "method": "master_theorem",
        "method_enum": "master_theorem",
        "complexity": "log n",
        "steps": [
          "**Paso 1 - Parámetros:**",
          " a = 1, b = 2",
          " f(n) = 1",
          "",
          "**Paso 2 - Exponente Crítico:**",
          " log_2(1) ≈ n^0",
          "",
          "**Paso 3 - Análisis de Límite (SymPy):**",
          " f(n) y n^0 crecen a la misma velocidad.",
          "",
          "**Paso 4 - Conclusión:**",
          " Aplica **Caso 2**",
          " Término dominante: log n"
        ],
        "explanation": "1.  **Identificación de Parámetros:**\n    *   `a = 1`: Indica que cada problema se divide en 1 subproblema.\n    *   `b = 2`: Indica que el tamaño de cada subproblema es `n/2`.\n    *   `f(n) = 1`: Representa el costo del trabajo adicional (dividir y combinar) en cada nivel de la recursión, que es una constante.\n\n2.  **Cálculo del Exponente Crítico (E):**\n    *   Calculamos `E = log_b a`.\n    *   Sustituyendo los valores: `E = log_2 1`.\n    *   Sabemos que cualquier número elevado a la potencia de 0 es 1, por lo tanto, `log_2 1 = 0`.\n    *   Así, el término `n^E` es `n^0`, que es igual a `1`.\n\n3.  **Análisis del Límite (Comparación de f(n) con n^E):**\n    *   Ahora comparamos `f(n)` con `n^E` calculando el límite: `lim (f(n) / n^E)` cuando `n` tiende a infinito.\n    *   Sustituyendo los valores: `lim (1 / 1)` cuando `n` tiende a infinito.\n    *   El límite es `1` (una constante).\n\n4.  **Interpretación del Límite y Determinación del Caso:**\n    *   Dado que el límite es una constante (no 0 ni infinito), esto significa que `f(n)` y `n^E` (es decir, `1` y `1`) crecen a la misma velocidad asintóticamente.\n    *   Esta situación corresponde al **Caso 2** del Teorema Maestro.\n\n5.  **Conclusión de la Complejidad:**\n    *   Para el Caso 2, la complejidad se define como `n^E * log n`.\n    *   Sustituyendo `E = 0`: `n^0 * log n`.\n    *   Como `n^0 = 1`, la complejidad final es `1 * log n`, que se simplifica a `log n`.",
        "details": {
          "complexity": "log n",
          "steps": [
            "**Paso 1 - Parámetros:**",
            " a = 1, b = 2",
            " f(n) = 1",
            "",
            "**Paso 2 - Exponente Crítico:**",
            " log_2(1) ≈ n^0",
            "",
            "**Paso 3 - Análisis de Límite (SymPy):**",
            " f(n) y n^0 crecen a la misma velocidad.",
            "",
            "**Paso 4 - Conclusión:**",
            " Aplica **Caso 2**",
            " Término dominante: log n"
          ],
          "explanation": "1.  **Identificación de Parámetros:**\n    *   `a = 1`: Indica que cada problema se divide en 1 subproblema.\n    *   `b = 2`: Indica que el tamaño de cada subproblema es `n/2`.\n    *   `f(n) = 1`: Representa el costo del trabajo adicional (dividir y combinar) en cada nivel de la recursión, que es una constante.\n\n2.  **Cálculo del Exponente Crítico (E):**\n    *   Calculamos `E = log_b a`.\n    *   Sustituyendo los valores: `E = log_2 1`.\n    *   Sabemos que cualquier número elevado a la potencia de 0 es 1, por lo tanto, `log_2 1 = 0`.\n    *   Así, el término `n^E` es `n^0`, que es igual a `1`.\n\n3.  **Análisis del Límite (Comparación de f(n) con n^E):**\n    *   Ahora comparamos `f(n)` con `n^E` calculando el límite: `lim (f(n) / n^E)` cuando `n` tiende a infinito.\n    *   Sustituyendo los valores: `lim (1 / 1)` cuando `n` tiende a infinito.\n    *   El límite es `1` (una constante).\n\n4.  **Interpretación del Límite y Determinación del Caso:**\n    *   Dado que el límite es una constante (no 0 ni infinito), esto significa que `f(n)` y `n^E` (es decir, `1` y `1`) crecen a la misma velocidad asintóticamente.\n    *   Esta situación corresponde al **Caso 2** del Teorema Maestro.\n\n5.  **Conclusión de la Complejidad:**\n    *   Para el Caso 2, la complejidad se define como `n^E * log n`.\n    *   Sustituyendo `E = 0`: `n^0 * log n`.\n    *   Como `n^0 = 1`, la complejidad final es `1 * log n`, que se simplifica a `log n`.",
          "applicable": true,
          "method": "Teorema Maestro",
          "case": "Caso 2",
          "a": 1,
          "b": 2,
          "log_b_a": "n^0"
        },
        "classification_confidence": 0.95,
        "classification_reasoning": "Ecuación en forma T(n) = aT(n/2) + f(n). Divide el problema en 1 subproblema(s) de tamaño n/2. Trabajo adicional: =+1,=1. El Teorema Maestro es el método óptimo."
      }
    ],
    "was_replicated": true
  }
}